System.Settings:
notifications_use_ring_volume ---+--> ze by na odlinkovanie zvonenia a notifikacii?
unlink_volumes_together ---------+
mute_streams_affected
mode_ringer_streams_affected

System.Global:
heads_up_notifications_enabled


Ako disablovat lockscreen, 2 kroky:
1. nastavit, ze power tlacitko nema lockovat
  /data/system/locksettings.db - lockscreen.power_button_instantly_locks (0,1)
  len je otazka, ci toto existuje aj na starsich androidoch ako 5.0
2. nastavit lockscreen timeout 
  Settings.Secure - lock_screen_lock_after_timeout (milisekundy)


--------

4. sprav notifikaciu ako dasboard, kde budu ikony profilov, klikom na ikonu sa profil aktivuje.
   poradie bude take iste ako pro aktivatore. Ak sa nezmestia na jednu notifikaciu, spravit dalsiu.
   Notifikacia bude mat prioritu nastavitelnu, default bude Minimal. Uzivatel si bude moct zmenit, aby sa
   takat notifikacia zobrazila aj v lockscreene. ;-)

--------

---------- PIN/password

1. ako zrusim pin/heslo

deviceManager.setPasswordMinimumLength(compName, 0);
boolean result = deviceManager.resetPassword("", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);

2. ako nahodim pin/heslo

DevicePolicyManager deviceManager = (DevicePolicyManager)getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName compName = new ComponentName(MessageService.this, LockAdmin.class);  

boolean active = deviceManager.isAdminActive(compName);  

if (active) { 
  deviceManager.setPasswordQuality(compName,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
  deviceManager.setPasswordMinimumLength(compName, 5);

  boolean result = deviceManager.resetPassword("blablabla", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);
}

3. password quality:

DevicePolicyManager.PASSWORD_QUALITY_SOMETHING - pattern lock?
DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK - tvar, odtlacok prstu?
DevicePolicyManager.PASSWORD_QUALITY_NUMERIC - pin?
DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_COMPLEX - heslo?

--------------------------------

NFC tag senzor - NEFUNGUJE PRI CITANI TAGU NA POZADI!

Tu mas ako sa to id cita: https://gist.github.com/luixal/5768921.

- Sprav aby to len citalo UID a to pouzivaj na identifikaciu tagu.
  Takto precitas UID: https://gist.github.com/luixal/5768921
- Na nacitanie tagu v NFCTagPreference sa vytvori nova aktivita NFCTagReadEditorActivity.
  Ta bude normalna ako je teraz NFCTagWritreActivity, ktoru zahodim.
  Zobrazovat bude precitane UID tagu a aj jeho obsah.
  Aj citanie by malo zacat automaticky, ked prilozim tag ku mobilu.
- Pridanie tagu nech hned vyvola citanie UID
- Write to tag polozku menu tagu zrus a zamen za citanir UID tagu
- Premenovanie tagu teraz je nahovno, nespravi aj zapis dso tagu, ale po novom to bude OK ako to je.
- V tabulke TABLE_NFC_TAGS pribudne polozka KEY_NT_UID = "uid". Tam sa zapise precitane uid.
- Aby bola spatna kompatibilita so starymi tagmi, bude NFCTagReadActivity citat uid aj obsah tagu.
  Ak bude uid v tabulke KEY_NT_UID prazdne, pouzije sa ako teraz obsah tagu. Inac sa pouzije uid tagu.
- Pre NFCTagReadActivity zmenit v manifeste intent filter na tento:
    <intent-filter>
        <action android:name="android.nfc.action.TAG_DISCOVERED"/>
        <category android:name="android.intent.category.DEFAULT"/>
      </intent-filter>

----------------------

Brightness in Pie

https://android.googlesource.com/platform/frameworks/base/+/master/packages/SettingsLib/src/com/android/settingslib/display/BrightnessUtils.java
https://android.googlesource.com/platform/frameworks/base/+/master/packages/SystemUI/src/com/android/systemui/settings/BrightnessController.java

public static final int GAMMA_SPACE_MAX = 1023;

// returns value from 0 to 1
private double getCurrentBrightness() {
        final int mMinBrightness = 0;
        final int mMaxBrightness = 255;

        final int value;

        value = convertLinearToGamma(Settings.System.getInt(mContentResolver,
                System.SCREEN_BRIGHTNESS, mMinBrightness),
                mMinBrightness, mMaxBrightness);

        return getPercentage(value, 0, GAMMA_SPACE_MAX);
    }

private double getPercentage(double value, int min, int max) {
        if (value > max) {
            return 1.0;
        }
        if (value < min) {
            return 0.0;
        }
        return (value - min) / (max - min);
    }

private void setCurrentBrightness(double value) {
    final int mMinBrightness = 0;
    final int mMaxBrightness = 255;

    final int val = convertGammaToLinear(value, mMinBrightness, mMaxBrightness);

    Settings.System.putInt(mContext.getContentResolver(), System.SCREEN_BRIGHTNESS, val);
}

// Hybrid Log Gamma constant values
private static final float R = 0.5f;
private static final float A = 0.17883277f;
private static final float B = 0.28466892f;
private static final float C = 0.55991073f;

public static final int convertLinearToGamma(int val, int min, int max) {
        // For some reason, HLG normalizes to the range [0, 12] rather than [0, 1]
        final float normalizedVal = MathUtils.norm(min, max, val) * 12;
        final float ret;
        if (normalizedVal <= 1f) {
            ret = MathUtils.sqrt(normalizedVal) * R;
        } else {
            ret = A * MathUtils.log(normalizedVal - B) + C;
        }
        return Math.round(MathUtils.lerp(0, GAMMA_SPACE_MAX, ret));
    }

public static final int convertGammaToLinear(int val, int min, int max) {
        final float normalizedVal = MathUtils.norm(0, GAMMA_SPACE_MAX, val);
        final float ret;
        if (normalizedVal <= R) {
            ret = MathUtils.sq(normalizedVal / R);
        } else {
            ret = MathUtils.exp((normalizedVal - C) / A) + B;
        }
        // HLG is normalized to the range [0, 12], so we need to re-normalize to the range [0, 1]
        // in order to derive the correct setting value.
        return Math.round(MathUtils.lerp(min, max, ret / 12));
    }

-------------------------------

Direct boot:
- toto je super na to, aby sa PPP startol aj pri uzamknutej obrazovke.
- android.intent.action.LOCKED_BOOT_COMPLETED vid:
    https://medium.com/@jordan_shifter/direct-boot-on-android-nougat-71f06c4a7c9e
- Ak nepuzijes direct boot, tak apka pada napr. v Fabric, android_job.
  To preto, lebo chcu pouzivat shared preferences a v uzamknutej obrazovke bez direct boot
  to spadne na IllegalStateException.
- Ako spravit podporu Direct boot:
    https://developer.android.com/training/articles/direct-boot
- Len mam taky strasne blby pocit, ze prave Fabric, android_job bude problem. neviem ako movnut
  shared preferences z device do credential storage. Nepoznam nazvy shared preferences a
  databazy.
  Vid:
    https://developer.android.com/reference/android/content/Context#moveSharedPreferencesFrom(android.content.Context,%20java.lang.String)
    https://developer.android.com/reference/android/content/Context#moveDatabaseFrom(android.content.Context,%20java.lang.String)
  Alebo, ze by pomohlo toto?
    https://stackoverflow.com/questions/51377089/android-crashlytics-fails-on-direct-boot-due-to-disk-encryption

---------------------------------
Extender:
- Vypada to, ze parametrov, ktore pouzivaju Extender je stale viac.
- Co tak spravit daky dialog, z ktoreho sa bude dat Extender managovat?
- Aby nemuseli byt pri kazdom profil/event parametri 3 dalsie kvoli Extenderu.
- Pridaj dakde v Editore daku indikaciu, ze je Extender vyzadovany v novej verzii.
  Nieco uz o tom mas v Important info, notifikacia o tom sa zobrazi po upgrade PPP.

- Zatial pridaj aspon upozornenie, ze je stary Extender. Mozno to uz mam, kukni.
  Sprav to ako pri pravach a podobne. Pis aj verziu, ktora je vyzadovana.

Kde je treba Extender:

Profily:
- Force stop application
- Lock device

Eventy:
- Call sensor
- SMS/MMS sensor
- Application sensor
- Orientation sensor

----------------------------------------------

Android Q beta 1 - emulator:

2019-03-15 19:40:37.496 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: java.io.FileNotFoundException: /system/build.prop: open failed: EACCES (Permission denied)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.IoBridge.open(IoBridge.java:496)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.io.FileInputStream.<init>(FileInputStream.java:159)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.isMIUI(PPApplication.java:1945)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.<clinit>(PPApplication.java:59)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.lang.Class.newInstance(Native Method)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.AppComponentFactory.instantiateApplication(AppComponentFactory.java:62)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.support.v4.app.CoreComponentFactory.instantiateApplication(CoreComponentFactory.java:49)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.Instrumentation.newApplication(Instrumentation.java:1144)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.LoadedApk.makeApplication(LoadedApk.java:1211)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6144)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.access$1100(ActivityThread.java:208)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1769)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.os.Handler.dispatchMessage(Handler.java:106)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.os.Looper.loop(Looper.java:209)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:7021)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.lang.reflect.Method.invoke(Native Method)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:486)
2019-03-15 19:40:37.522 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:872)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: Caused by: android.system.ErrnoException: open failed: EACCES (Permission denied)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.Linux.open(Native Method)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.ForwardingOs.open(ForwardingOs.java:167)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.BlockGuardOs.open(BlockGuardOs.java:237)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.IoBridge.open(IoBridge.java:482)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: 	... 17 more
2019-03-15 19:40:37.524 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: java.io.FileNotFoundException: /system/build.prop: open failed: EACCES (Permission denied)
2019-03-15 19:40:37.524 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.IoBridge.open(IoBridge.java:496)
2019-03-15 19:40:37.524 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.io.FileInputStream.<init>(FileInputStream.java:159)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.getEmuiRomName(PPApplication.java:1969)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.isEMUI(PPApplication.java:1990)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.<clinit>(PPApplication.java:60)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.lang.Class.newInstance(Native Method)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.AppComponentFactory.instantiateApplication(AppComponentFactory.java:62)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.support.v4.app.CoreComponentFactory.instantiateApplication(CoreComponentFactory.java:49)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.Instrumentation.newApplication(Instrumentation.java:1144)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.LoadedApk.makeApplication(LoadedApk.java:1211)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6144)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.access$1100(ActivityThread.java:208)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1769)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.os.Handler.dispatchMessage(Handler.java:106)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.os.Looper.loop(Looper.java:209)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:7021)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.lang.reflect.Method.invoke(Native Method)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:486)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:872)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: Caused by: android.system.ErrnoException: open failed: EACCES (Permission denied)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.Linux.open(Native Method)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.ForwardingOs.open(ForwardingOs.java:167)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.BlockGuardOs.open(BlockGuardOs.java:237)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.IoBridge.open(IoBridge.java:482)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: 	... 18 more

----------------------------------------------------------------

Registracia mobilnych buniek:
- Kazda udalost ma MobileCellsRegistrationDialogPreferenceX.
  Ten na Start/Stop button prida/uberie udalostt, pre ktoru sa registracia robi.
- MobileCellsRegistrationService bezi na pozadi a meria dlzku registracie.
  V pravidelnych intervaloch posiela broadcast ACTION_MOBILE_CELLS_REGISTRATION_COUNTDOWN.
  Ten je len na update GUI v EventsPrefsActivity.
- Samotnu registraciu robi PhoneStateScanner v doAutoRegistration().

- "Not used mobile cell" detektor som vyhodil. Chcem ho vratit spat.
- V prvom rade treba vyriesit, aby sa nenotifikoval jeden cell viac krat. Sice uz len jedna
  notifikacia sa zobrazi, ale stale to dava zvuk.
- Samotne notifikacie uzivatela otravuju. Treba porozmyslat, ako to spravit inac.
  Napriklad tak, ze bude len jedna notifikacia, Nie pre kazdu bunku zvlast, ale ze sa bude
  pamatat: bunka, cas, udalosti, ktorych sa tyka.
  Notifikacia otvori nie dialog, ale aktivitu, kde sa zobrazi zoznam: bunka, cas a udlaosti.
  Kliknutim na item zoznamu sa zobrazi uz teraz existujuci dialog. Dialog na OK, Cancel item
  zo zoznanmu vyhodi.
- Toto by mohlo eliminovat tieto notifikacie.

------------------------------------------------------------------

Migracia z android-job do WorkManager:
- android-job jobBuilder.startNow() ->

    OneTimeWorkRequest work = OneTimeWorkRequest.Builder(MyWorker::class.java)
                .setInputData(inputData)
                .addTag(JOB_TAG)
                .build()
    WorkManager.getInstance().enqueue(work)

- android-job jobBuilder.setExact() ->

    OneTimeWorkRequest save = new OneTimeWorkRequest.Builder(SaveImageToFileWorker.class)
                .setInitialDelay(20, TimeUnit.MINUTES)
                .setInputData(inputData)
                .addTag(JOB_TAG)
                .build();

- android-job jobBuilder.setPeriodic() ->

    PeriodicWorkRequest workRequest =
                new PeriodicWorkRequest.Builder(WorkerClass.class, interval, TimeUnit.MINUTES)
                        .setInputData(inputData)
                        .addTag(JOB_TAG)
                        .build();

- android job JobRequest.MIN_INTERVAL ->

    PeriodicWorkRequest.MIN_PERIODIC_INTERVAL_MILLIS

- android-job jobManager.cancelAllForTag(JOB_TAG) ->

    WorkManager.getInstance().cancelAllWorkByTag(JOB_TAG);

- android-job jobBuilder.setExtras(bundleCompat) ->

    Data imageData = new Data.Builder
                    .putString(Constants.KEY_IMAGE_URI, imageUriString)
                    .build();

    OneTimeWorkRequest uploadWorkRequest = new OneTimeWorkRequest.Builder(UploadWorker.class)
            .setInputData(imageData)
            .build()

- android-job protected Result onRunJob(@NonNull Params params) params.getStringExtra() ->

    public Result doWork() {

        // Get the input
        String imageUriInput = getInputData().getString(Constants.KEY_IMAGE_URI)

    }

- android-job WifiScanJob.isJobScheduled ->

    https://stackoverflow.com/questions/51612274/check-if-workmanager-is-scheduled-already/51613101

    WorkManager instance = WorkManager.getInstance();
    ListenableFuture<List<WorkInfo>> statuses = instance.getWorkInfosByTag(tag);
    try {
        List<WorkInfo> workInfoList = statuses.get();
        return workInfoList.size() != 0;
    } catch (ExecutionException e) {
        e.printStackTrace();
        return false;
    } catch (InterruptedException e) {
        e.printStackTrace();
        return false;
    }

- android-job WifiScanJob._cancelJob ->

    https://stackoverflow.com/questions/51612274/check-if-workmanager-is-scheduled-already/51613101

    private static void _cancelJob(final Context context) {
        if (isJobScheduled()) {
            try {
                JobManager jobManager = JobManager.instance();

                PPApplication.logE("WifiScanJob._cancelJob", "START WAIT FOR FINISH");
                long start = SystemClock.uptimeMillis();
                do {
                    if (!isJobScheduled()) {
                        PPApplication.logE("WifiScanJob._cancelJob", "NOT SCHEDULED");
                        break;
                    }

                    // WorkManage code -------------------------
                    WorkManager instance = WorkManager.getInstance();
                    ListenableFuture<List<WorkInfo>> statuses = instance.getWorkInfosByTag(tag);
                    boolean allFinished = true;
                    try {
                        List<WorkInfo> workInfoList = statuses.get();
                        for (WorkInfo workInfo : workInfoList) {
                            WorkInfo.State state = workInfo.getState();
                            if (!state.isFinished()) {
                                allFinished = false;
                                break;
                            }
                        }
                    } catch (ExecutionException e) {
                        e.printStackTrace();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    //-----------------------------------------

                    if (allFinished) {
                        PPApplication.logE("WifiScanJob._cancelJob", "FINISHED");
                        break;
                    }

                    //try { Thread.sleep(100); } catch (InterruptedException e) { }
                    SystemClock.sleep(100);
                } while (SystemClock.uptimeMillis() - start < WifiBluetoothScanner.wifiScanDuration * 1000);
                PPApplication.logE("WifiScanJob._cancelJob", "END WAIT FOR FINISH");

                setScanRequest(context, false);
                setWaitForResults(context, false);
                WifiBluetoothScanner.setForceOneWifiScan(context, WifiBluetoothScanner.FORCE_ONE_SCAN_DISABLED);

                //jobManager.cancelAllForTag(JOB_TAG_SHORT);
                jobManager.cancelAllForTag(JOB_TAG);

                PPApplication.logE("WifiScanJob._cancelJob", "CANCELED");

            } catch (Exception ignored) {
            }
        }
    }

- android-job Job.onCancel() ->

    Worker.onStopped()

--------------------------------------------------------------------

Classic a LE scanning:

- skener skenuje vzdy Classic aj LE sposobom
- pozera, ake typy skenovania su nakonfigurovane v udalostiach
  - ked su classic, skenujem classic skenom
  - ked su LE skenujem LE skenom
  - cize vysledkom moze byt, ze skenujem oboma typmi
- len pre LE scan ziadam zapnutu BT - TOTO POZRI, CI NAHODOU NIE JE NUTNE AJ PRE CLASSIC SCAN
- pre oboje zapinam Bluetooth, ak je vypnute

- Vypada to tak, ze:
- LE scan nevie vratit classic BT zariadenie
- Classic scan skenuje oba typy zariadenia, pre oba vratilo meno BT zariadenia

- Ten device type parameter u udalosti je uplne neprehladny.
- Hlavne uzivatel nevie, co ma nastavit.
- Pre oba zapinam BT, pre LE vyzadujem zapnutu lokaciu
- Co tak teda vyhodit ten device type a proste vzdy skenovat oba typy
- Potom netreba ani, akeho typu je BT zariadenie, cize mozu sa vyhodit [CL], [DU], [LE] indikatory

------------------------------------------------------------------------

Permissions vz. Root/G1

checkProfileVibrationOnTouch(context, profile, permissions);
_vibrationOnTouch

checkProfileVibrateWhenRinging(context, profile, permissions);
_vibrateWhenRinging (R)

checkProfileRingtones(context, profile, permissions);
_soundRingtoneChange
_soundNotificationChange
_soundAlarmChange

checkProfileScreenTimeout(context, profile, permissions);
_deviceScreenTimeout

checkProfileScreenBrightness(context, profile, permissions);
getDeviceBrightnessChange() (R)

checkProfileAutoRotation(context, profile, permissions);
_deviceAutoRotate

checkProfileNotificationLed(context, profile, permissions);
_notificationLed (R)

checkProfileWallpaper(context, profile, permissions);
_deviceWallpaperChange

checkProfileRadioPreferences(context, profile, permissions);
_deviceWiFiAP (R)
_deviceBluetooth
_deviceMobileData (R)
_deviceNetworkType (R)
_deviceConnectToSSID

checkProfilePhoneBroadcast(context, profile, permissions);
_volumeSpeakerPhone

checkCustomProfileIcon(context, profile, permissions);
getIsIconResourceID()

checkProfileAccessNotificationPolicy(context, profile, permissions);
_volumeRingerMode

checkProfileLockDevice(context, profile, permissions);
_lockDevice (R)

checkProfileDtmfToneWhenDialing(context, profile, permissions);
_dtmfToneWhenDialing

checkProfileSoundOnTouch(context, profile, permissions);
_soundOnTouch

-------------------------------------------

1. PPApplication.createProfileNotificationChannel(appContext);
This is channel for main "foreground" notification of PhoneProfilesService. Is used for show permanent notification of activated profile. And is visible all the time PPP running.
PRIORITY_DEFAULT, PRIORITY_MIN
For Android < 8: Notification sounds and vibrates, when it is enabled in system.
For Android >= 8: sound and vibration is disabled (IMPORTANCE_LOW)

2. PPApplication.createMobileCellsRegistrationNotificationChannel(appContext);
This is channel for "Mobile cells registration" function. It is also permanent notification, visible only during mobile cells registration.
PRIORITY_MAX - change to PRIORITY_DEFAULT
For Android < 8: Notification sounds and vibrates, when it is enabled in system.
For Android >= 8: sound and vibration is disabled (IMPORTANCE_LOW)

3. PPApplication.createInformationNotificationChannel(appContext);
This is channel for non-permananet notification. Is for informations notifications.
PRIORITY_MAX - change to PRIORITY_DEFAULT
For Android < 8: Notification sounds and vibrates, when it is enabled in system.
For Android >= 8: sound is enabled, vibration is disabled (IMPORTANCE_LOW)

4. PPApplication.createExclamationNotificationChannel(appContext);
This is channel for non-permananet notification. Is for exclamations notifications.
PRIORITY_MAX
For Android < 8: Notification sounds and vibrates, when it is enabled in system.
For Android >= 8: sound and vibration is enabled (IMPORTANCE_DEFAULT)

5. PPApplication.createGrantPermissionNotificationChannel(appContext);
This is channel for non-permananet notification. Is for notifications, when some permission is needed and is not granted.
PRIORITY_MAX
For Android < 8: Notification sounds and vibrates, when it is enabled in system.
For Android >= 8: sound and vibration is enabled (IMPORTANCE_DEFAULT)

6. PPApplication.createNotifyEventStartNotificationChannel(appContext);
This is channel for event start notifications, when in Event/Start of event/Other parameters is configured "Notification sound" and/or "Notifiy by vybration" and "Repeat notification" is enabled.
PRIORITY_MAX - change to PRIORITY_DEFAULT
For Android < 8: Notification sounds and vibrates, when it is enabled in system.
For Android >= 8: sound and vibration is disabled (IMPORTANCE_LOW)

7. PPApplication.createMobileCellsNewCellNotificationChannel(appContext);
This is channel for non-permanent notification, used, when is enabled Settings/MobileSells scanning/Show notification for detection of not used mobile cells
PRIORITY_MAX
For Android < 8: Notification sounds and vibrates, when it is enabled in system.
For Android >= 8: sound and vibration is enabled (IMPORTANCE_DEFAULT)

8. PPApplication.createDonationNotificationChannel(appContext);
This is channel for non-permanent notification, used, for notification abount Donation.
PRIORITY_MAX - change to PRIORITY_DEFAULT
For Android < 8: Notification sounds and vibrates, when it is enabled in system.
For Android >= 8: sound is enabled, vibration is disabled (IMPORTANCE_LOW)

----------------------------------------

Optimalizacia Editora a priprava na ViewPager:

- Mozes pre Editor pouzit pre profily jeden jediny layout. Lisia sa len indikatorom v headeri.
  Ten mozes krasne schovavat, ak su vypnute indikatory
- Potom uz nie je problem vytvorit jeden jediny fragment pre profily a jeden jediny pre udalosti.
  Netreba pri zmene fiktra vytvarat nanovo cely fragment.
  Na zmenu filtra len do prislusneho fragmentu posles nove parametre, ktore teraz davas ago argumenty pri vytvarani fragmentu.
- Ked toto budes mat, nebude sa pri kasdej zmene filtra znova nacitatavat zoznam profilov a udalosti z databazy.
  Lebo adapter ich filtruje sam, podla nastaveneho filtra v aktivite.
  Treba akurat vyriesit zmenu poradia profilov a udalosti.
  Totizto v AsyncTasku ich sortujem.
- Potom bude omnoho jednoduchsie spravit ten ViewPager pre Editor.

----------------------------------------

- Dostupnost: cize Accessibility service - bud PPP zobrazuje hned v zozname alebo treba kliknut na "Nainstalovane sluzby".
  Tam treba najst "PhoneProfilesPlusExtender" a povolit ho.
- System nastavenia polohy: treba povolit pouzivanie polohy.
- Pristup k upozrneniam: treba najst v zozname "PhoneProfilesPlus" a povolt ho.
- Optimalizacia baterie: Treba hore prepnut na "Vsetky", najst "PhoneProfilesPlus" a zakazat ho. Aby neoptimalizoval.
- Setric baterie: toto pozri na Nexuse, mne to preplo na "Rezim vykonu". Tam nic nemenim.
  Ktohovie, co sa zobrazuje pri inych mobiloch. Testni.
- Povolenie "Uprava nastaveni systemu": Zobrazi sa priamo pre PPP. Cize netreba dialog.
- Povolenie "Pristup k nastaveniu Nerusit": Treba najst "PhoneProfilesPlus" a povolit ho.
- Povolenie "Vykreslit cez dalsie apliakcie": Zobrazi sa priamo pre PPP. Cize netreba dialog.
- Povolenia pre aplikaciu: ak to je z nastaveni profilu/udalosti, netreba robit nic. Ak je to Nastavenia aplikacie,
  treba kliknut na "Opravnenia" a tam povolit prislusne opravnenia.
- Stavovy riadok - Systemove nastavenia: otvori nastavenia kanala "Aktivovany profil". Tu nech si nastavi to, co potrebuje.

Totot vypada, ze je to vsetko, ale odporucam pozriet v kode, co je vsetko volane.
Pozri kedy je to volane (Android verzia) a hladaj to v nastaveniach systemu.

Hladaj: R.string.setting_screen_not_found_alert

--------------------------------------

- DonationBroadcastReceiver -> raz denne v presny cas, pouziva aj AlarmClock
- EventPreferencesAlarmClock -> raz denne v presny cas, pouziva aj AlarmClock
- EventPreferencesCalendar -> raz denne v presny cas, pouziva aj AlarmClock
- EventPreferencesCall -> raz denne v presny cas, pouziva aj AlarmClock
- EventPreferencesNFC -> raz denne v presny cas, pouziva aj AlarmClock
- EventPreferencesNotification -> raz denne v presny cas, pouziva aj AlarmClock
- EventPreferencesSMS -> raz denne v presny cas, pouziva aj AlarmClock
- EventPreferencesTime -> raz denne v presny cas, pouziva aj AlarmClock
- TwilightScanner -> raz denne v presny cas, pouziva aj AlarmClock


Tieto maju od uzivatela parameter duration, delay:
- Event.setDelayStartAlarm -> cas od now() + delay, pouziva aj AlarmClock
- Event.setDelayEndAlarm -> cas od now() + delay, pouziva aj AlarmClock
- ProfileDurationAlarmBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock
- RunApplicationWithDelayBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock
Tento sa pouziva pre repeat zvukovu a vibracnu notifikaciu startu udalosti:
- StartEventNotificationBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock

Tento sa pouziva na spracovanie udalosti na screen off ale az po jeho loknuti:
- LockDeviceAfterScreenOffBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock,
uzivatel moze zadat interval, ale len v device Settings.

Tento sa pouziva na prepinanie GPS on/off:
- GeofencesScannerSwitchGPSBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock, uzivatel nemoze
zadat interval, je natvrdo 1 alebo 30, podla toho, ci sa ma pouizvat GPS. Toto je kandidat na WorkManagera.

Tento sa pouziva na zavretie lock device aktivity:
- LockDeviceActivityFinishBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock,
uzivatel nemoe zadat interval, je natvrdo 20 sekund. Toto ma sledovat, ci uzivatel vypol obrazovku
a ked nie, ma sa LockDeviceActivity zavriet. Toto je kandidat na WorkManagera.

--------------------------------------

https://mail.google.com/mail/u/0/#inbox/FMfcgxwGCGzLSzHXNSXxmMFsKjrPZZMT
Pozri, cele je to v implementation 'com.google.firebase:firebase-analytics:17.2.1'
Musia to upgradnut, inac ho budem musiet vyhodit.

