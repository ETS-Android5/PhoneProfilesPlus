------------------------
funkční nastavení pro Huawei P30 s Androidem 10 a EMUI 10.

nastavení-aplikace- aplikace-PPP-podrobnosti o spotřebě energie-spouštění aplikací:
Spravovat automaticky - ne
Spravovat ručně 3x ano
-automatické souštění
-sekundární souštění
-Spustit na ozadí
------------------------

Ulohy, ktore su spravene [x] a ktore nie [ ]:
[ ] Priority Notification Event
[ ] Normal media volume, headphone media volume, Bluetooth media volume
[ ] Sony's "Stamina" mode as profile preference - skor Power save change senzor
[ ] USB connection to PC as storage device, USB connection to PC as camera, connection to USB stick in accessories parameter for events
[ ] option to hide PPP from Launcher
[ ] Set min and max CPU frequency
[ ] Open a website with profile
[ ] profile/event search
[ ] Persistent profile/event: sets its options every x minutes - asi periodic sensor
[ ] Android Wear support?
[ ] (AND, OR, XOR, NOT. Or at least NOT.)<-NOT is already available in most preferences. If that stays, that does the same.
[ ] a plugin system? (very small core app, ability to install additional event preferences, maybe only time event preinstalled)

------------------------

UNDO:
=====

Na "Undo profile" sa pouziva FIFO, je to vlastne zoznam profilov a udalosti v poradi, v akom sa aktivovali, spustili.

1. DataWrapper.fifoAddProfile()

PhoneProfilesService.doFirstStart() - PPApplication.prefLastActivatedProfle, 0
DataWrapper._activateProfile() - profileId (ktory sa aktivuje), 0
DataWrapper.activateProfileFromEvent() - profieId, event_id
Event.startEvent() - profileId, _id - ked nejde o merge profilov a nie je to manualna aktivacia z udalosti
Event.doActivateEndProfile() - profileId, _id - ked nejde o merge profilov a nie je to manualna aktivacia z udalosti

koniec udalosti, nie je manualne aktivovany profil:
EventsHandler.handleEvents() - defaultProfile, 0 - ak ide o aktivaciu default profilu, je nakonfigurovany
EventsHandler.handleEvents() - PPApplication.prefLastActivatedProfile, 0 - ak nie je nakonfigurovany default profile

koniec udalosti, je manualne aktivovany profil:
EventsHandler.handleEvents() - semiOldActivatedProfileId, 0 - ak je aktivovany daky profil
EventsHandler.handleEvents() - defaultProfile, 0 - ak nie je aktivovany daky profil a ide o aktivaciu default profilu, je nakonfigurovany
EventsHandler.handleEvents() - PPApplication.prefLastActivatedProfile, 0 - ak nie je aktivovany daky profil a nie je nakonfigurovany default profile

2. DataWrapper.fifoSaveProfiles()

DataWrapper.activateProfile() - pre STARTUP_SOURCE_FOR_FIRST_START - vyprazdni FIFO
EditorProfileListFragment.deleteProfile() - vymaze vymazavany profil z FIFO
EditorProfileListFragment.deleteAllProfiles() - vyprazdnenie FIFO
EventHlandler.handleEvents() - vyprazdnenie FIFO pri starte udalosti pred spustanim udalosti
PhoneProfilesService.doForFirstStart() - vyprazdnenie FIFO na prvy start, potom hned nasleduje pridanie PPApplication.prefLastActivatedProfile
PPApplication._exitApp() - vyprazdnenie FIFO na ukoncenie PPP


Ako sa robi UNDO:

Event.doActivateEndProfile() - ak je EATENDDO_UNDONE_PROFILE - pre merge an non-merge profiles
- Spravi sa zonznam FIFO udalosti, ktore nie su rovne ukoncovanej udalosti.
  Profily z ukoncovanej udalosti nas uz nezaujimaju, vsetky sa z FIFO vymazu.
- Z novovzniknuteho FIFO sa vezme posledny profil a ten sa aktivuje

ProfileDurationAlarmBroadcastReceiver._doWork() - ak je AFTER_DURATION_DO_UNDO_PROFILE
- Vymaze sa posledny profil z FIFO, j jedno, ci ma priradenu udalost
- Potom za z FIFO vezme posledny profil a ten sa aktivuje

------------------------

System.Settings:
notifications_use_ring_volume ---+--> ze by na odlinkovanie zvonenia a notifikacii?
unlink_volumes_together ---------+
mute_streams_affected
mode_ringer_streams_affected

System.Global:
heads_up_notifications_enabled

Ako disablovat lockscreen, 2 kroky:
1. nastavit, ze power tlacitko nema lockovat
  /data/system/locksettings.db - lockscreen.power_button_instantly_locks (0,1)
  len je otazka, ci toto existuje aj na starsich androidoch ako 5.0
2. nastavit lockscreen timeout 
  Settings.Secure - lock_screen_lock_after_timeout (milisekundy)

--------

4. sprav notifikaciu ako dasboard, kde budu ikony profilov, klikom na ikonu sa profil aktivuje.
   poradie bude take iste ako pro aktivatore. Ak sa nezmestia na jednu notifikaciu, spravit dalsiu.
   Notifikacia bude mat prioritu nastavitelnu, default bude Minimal. Uzivatel si bude moct zmenit, aby sa
   takat notifikacia zobrazila aj v lockscreene. ;-)

--------

---------- PIN/password

1. ako zrusim pin/heslo

deviceManager.setPasswordMinimumLength(compName, 0);
boolean result = deviceManager.resetPassword("", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);

2. ako nahodim pin/heslo

DevicePolicyManager deviceManager = (DevicePolicyManager)getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName compName = new ComponentName(MessageService.this, LockAdmin.class);  

boolean active = deviceManager.isAdminActive(compName);  

if (active) { 
  deviceManager.setPasswordQuality(compName,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
  deviceManager.setPasswordMinimumLength(compName, 5);

  boolean result = deviceManager.resetPassword("blablabla", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);
}

3. password quality:

DevicePolicyManager.PASSWORD_QUALITY_SOMETHING - pattern lock?
DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK - tvar, odtlacok prstu?
DevicePolicyManager.PASSWORD_QUALITY_NUMERIC - pin?
DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_COMPLEX - heslo?

--------------------------------

NFC tag senzor - NEFUNGUJE PRI CITANI TAGU NA POZADI!

Tu mas ako sa to id cita: https://gist.github.com/luixal/5768921.

- Sprav aby to len citalo UID a to pouzivaj na identifikaciu tagu.
  Takto precitas UID: https://gist.github.com/luixal/5768921
- Na nacitanie tagu v NFCTagPreference sa vytvori nova aktivita NFCTagReadEditorActivity.
  Ta bude normalna ako je teraz NFCTagWritreActivity, ktoru zahodim.
  Zobrazovat bude precitane UID tagu a aj jeho obsah.
  Aj citanie by malo zacat automaticky, ked prilozim tag ku mobilu.
- Pridanie tagu nech hned vyvola citanie UID
- Write to tag polozku menu tagu zrus a zamen za citanir UID tagu
- Premenovanie tagu teraz je nahovno, nespravi aj zapis dso tagu, ale po novom to bude OK ako to je.
- V tabulke TABLE_NFC_TAGS pribudne polozka KEY_NT_UID = "uid". Tam sa zapise precitane uid.
- Aby bola spatna kompatibilita so starymi tagmi, bude NFCTagReadActivity citat uid aj obsah tagu.
  Ak bude uid v tabulke KEY_NT_UID prazdne, pouzije sa ako teraz obsah tagu. Inac sa pouzije uid tagu.
- Pre NFCTagReadActivity zmenit v manifeste intent filter na tento:
    <intent-filter>
        <action android:name="android.nfc.action.TAG_DISCOVERED"/>
        <category android:name="android.intent.category.DEFAULT"/>
      </intent-filter>

----------------------

Direct boot:
- Asi nemozem spravit, nepodporuje to WorkManager. :-(
- toto je super na to, aby sa PPP startol aj pri uzamknutej obrazovke.
- android.intent.action.LOCKED_BOOT_COMPLETED vid:
    https://medium.com/@jordan_shifter/direct-boot-on-android-nougat-71f06c4a7c9e
- Ak nepuzijes direct boot, tak apka pada napr. v Fabric, android_job.
  To preto, lebo chcu pouzivat shared preferences a v uzamknutej obrazovke bez direct boot
  to spadne na IllegalStateException.

  Fabric, android-job uz nepouzivam, treba testnut s Firebase Crashlytics a WorkManager

- Ako spravit podporu Direct boot:
    https://developer.android.com/training/articles/direct-boot

- Len mam taky strasne blby pocit, ze neviem ako movnut shared preferences z device do credential storage.
  Vid:
    https://developer.android.com/reference/android/content/Context#moveSharedPreferencesFrom(android.content.Context,%20java.lang.String)
    https://developer.android.com/reference/android/content/Context#moveDatabaseFrom(android.content.Context,%20java.lang.String)
  Alebo, ze by pomohlo toto?
    https://stackoverflow.com/questions/51377089/android-crashlytics-fails-on-direct-boot-due-to-disk-encryption

----------------------------------------

Extender:
- Vypada to, ze parametrov, ktore pouzivaju Extender je stale viac.
- Co tak spravit daky dialog, z ktoreho sa bude dat Extender managovat?
- Aby nemuseli byt pri kazdom profil/event parametri 3 dalsie kvoli Extenderu.
- Pridaj dakde v Editore daku indikaciu, ze je Extender vyzadovany v novej verzii.
  Nieco uz o tom mas v Important info, notifikacia o tom sa zobrazi po upgrade PPP.

----------------------------------------

EventsHandler.handleEvents()
- volane strasne vela krat zaujima ma restart udalosti a samotny orientacny senzor
- SENSOR_TYPE_DEVICE_ORIENTATION
  - z OrientationScanner.runEventsHandlerForOrientationChange() - zisti, aky thread to pouziva
  - z PPPExtenderBroadcastRecveiver.onReceive() - je to volane v HandlerThread - vroadcast treba, lebo senzor sleduje aplikacie na popredi

--------------

Start udalosti:
1. Start s delay nastavi alarm pre SENSOR_TYPE_EVENT_DELAY_START a NENASTAVI event._status na ESTATUS_RUNNING, necha ho ESTATUS_PAUSE
2. Po delay znova testuje, ci sa zmeni stav udalosti a tiez ci event._isInDelayStart je uz false. Az tu vola startEvemt(), cize nastavi ESTATUS_RUNNING.
Vysledok je, ze pocas delay je stale PAUSE az po delay je RUNNING.

Koniec udalosti:
1. Koniec s delay nastavi alarm pre SENSOR_TYPE_EVENT_DELAY_END a NENASTAVI event._status na ESTATUS_PAUSE, necha ho ESTATUS_RUNNING
2. Po delay znova testuje, ci sa zmeni stav udalosti a tiez ci event._isInDelayEnd je uz false. Az tu vola pauseEvemt(), cize nastavi ESTATUS_PAUSE.
Vysledok je, ze pocas delay je stale RUNNING az po delay je PAUSE.

-----------------

Battery historian:
1. sudo apt install docker.io
2. Ako pouzivat: https://developer.android.com/topic/performance/power/setup-battery-historian
3. Spustaj ale takto:
      sudo docker run -p 20000:9999 gcr.io/android-battery-historian/stable:3.0 --port 9999
4. V Chrome potom: http://localhost:20000

------------------

Toto daj do Important info. Je to ako nastavit PPP pre znizenie spotreby baterie:

1. Battery optimization, must by dislabled - it is PPP Settings/System/Ignore battery optimization
2. Scanning intervals, set it >= recommended
    - Background scanning = 15 minutes
    - Location scanning = 15 minutes
    - Wi-Fi scanning = 15 minutes
    - Bluetooth scanning = 15 minutes
    - Orientation scanning = 10 seconds
3. For location scanning disable "Use GPS when not in Power Save mode". This is required only when another location sources are not available.
    Location sources used by Android:
    - Wi-Fi
    - Bluetooth
    - network
    - mobile cells
    - GPS
4. For increasing location accuracy, you can force usage of Wi-Fi and BLuetooth as source. For this, enable it in Location system setting "Wi-Fi and Bluetooth scanning"
5. Battery sensor: do not use battery levels when are not needed. Set levels: 0%-100%

---------------------

Orientation sensor:
Light senzor sa generuje hrozne casto. Na Samsungu donekonecna a par krat za sekundu.
Spravil som sice:
- ze sa neregistruje, ak ziadna udalost ho nepouziva
- ze sa ma handler volat az o polovicu intervalu
Ale aj tak to musi zrat vela. Kazdych 5 sekund volat eventsHandler je proste vela.
Zatial mam nenapadlo, co s tym. Do nastaveni senzora daj aspon info preference o tom ze check light zerie bateriu.

-----------------------

Co je toto? Nastavenie tonu pri aktivacii profilu? Prehratie tonu na notifikacu?
Zistujem, ktory ton je nastaveny (najdi kde), preco by som ho mal aj prehravat? Nemam to nastavene.
2020-09-07 00:05:35.217 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:05:55.189 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:26:45.609 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:26:46.097 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:26:52.669 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:28:43.189 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:29:03.187 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other

------------------------

am mám funkční nastavení pro Huawei P30 s Androidem 10 a EMUI 10.

nastavení-aplikace- aplikace-PPP-podrobnosti o spotřebě energie-spouštění aplikací:
Spravovat automaticky - ne
Spravovat ručně 3x ano
-automatické souštění
-sekundární souštění
-Spustit na ozadí
třeba se to bude hodit.

-------------------------

ActivateProfileHelper.setScreenTimeout()
- disableScreenTimeoutInternalChange = true;
- pre kazdy timeout z parametra:
	if (PPApplication.lockDeviceActivity != null)
	    // in LockDeviceActivity.onDestroy() will be used this value to revert back system screen timeout
	    PPApplication.screenTimeoutBeforeDeviceLock = 15000;
	else {
      	    Settings.System.putInt(appContext.getContentResolver(), Settings.System.SCREEN_OFF_TIMEOUT, xxx);
      	}
- nerobi 6, 8. Preco?
- zavola:
        setActivatedProfileScreenTimeout(appContext, 0);
- zavola work:
	DisableScreenTimeoutInternalChangeWorker.class

- volane z:
  - ActivateProfileHelper.execute() - aktivacia profilu ak je obrazovka zapnuta
  - LockDeviceActivity.onDestroy() - na nastavenie timeoutu, ak sa este nenastavil
  - ScreenOnOffBroadcastReceiver.onReceive() na ACTION_USER_PRESENT

ActivateProfileHelper.setActivatedProfileScreenTimeout()
- ulozi do shared preferences timeout.
- ulozi to aj do ApplicationPreferences.prefActivatedProfileScreenTimeout
- pouzije to v ScreenOnOffBroadcastReceiver.onReceive() na ACTION_USER_PRESENT
- pouzije to aj v LockDeviceActivity.onDestroy() na vratenie timeoutu

- volane je z:
  - ActivateProfileHelper.setScreenTimeout() - nastavi 0, lebo netreba nastavovat na screen On ACTION_USER_PRESENT
  - ActivateProfileHelper.execute - nastavi profile parameter _deviceScreenTimeout, ak je screen off
  - SettingsContentObserver.onChange() - nastvi 0 ak posledny zapamatany timeout je iny ako aktualny. a  nie je to internalChange
                                                  ActivateProfileHelper.disableScreenTimeoutInternalChange
                                         to aby sa nepouzila na ten screen On ACTION_USER_PRESENT. Tu sa predpoklada, ze zmena prisla z vonka.

premenna PPApplication.screenTimeoutBeforeDeviceLock:
- tu si pamatam, aky timeout je pred spustenim LockDeviceActivity.
- na onCreate() ho zistuje
- na onDestroy() nastavi spat timeout na tuto odpamatanu hodnotu
- na onDestroy() potom nastavi timeot na hodnotu ApplicationPreferences.prefActivatedProfileScreenTimeout.


Takto sa nastavuje tiemout pri aktivacii profilu:
        // screen timeout
        if (Permissions.checkProfileScreenTimeout(appContext, profile, null)) {
            if (PPApplication.isScreenOn) {
                if (PPApplication.screenTimeoutHandler != null) {
                    PPApplication.screenTimeoutHandler.post(() -> {
                        setScreenTimeout(profile._deviceScreenTimeout, appContext);
                    });
            }
            else {
                setActivatedProfileScreenTimeout(appContext, profile._deviceScreenTimeout);
            }
        }
- cize ak je screen on, nastavi sa timeount hned.
- ak je screen off, nastavi sa timeount az v ScreenOnOffBroadcastReceiver.onReceive() na ACTION_USER_PRESENT
  cize len sa hodnota ulozi do ApplicationPreferences.prefActivatedProfileScreenTimeout.
Toto cele chapem.

-----

Inac spravit ten brightness
1. zapamatat si hodnoty na screen off
2. obnovit ich na screen on
3. aktivacia profilu nech tie hodnoty tiez nastavuje



