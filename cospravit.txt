------------------------

[x] location event (when at point X, radius Y)
[x] app event (when app X is started)
[x] Notification event lasts until notification is gone
[x] expand/shrink event and profile preferences, maybe with a checkbox instead of an arrow and all active preferences are expanded â€“ PPP use Android standard preference screens. Than I can only use subscreens. - Yes! If I understand you right, that was my idea.
[x] profile event (only when profile X is active, can't end event)
[x] notification event
[x] Seconds in profile duration
[x] 5 minutes as settable screen timeout
[ ] Priority Notification Event
[x] Restart events at boot option
[x] Restart events shortcut for launcher
[ ] Normal media volume, headphone media volume, Bluetooth media volume
[ ] Sony's "Stamina" mode as profile preference
[ ] USB connection to PC as storage device, USB connection to PC as camera, connection to USB stick in accessories parameter for events
[x] Option to delete logs after x days
[ ] Resizable grid in Activator
[ ] option to hide PPP from Launcher
[x] Not started/not shown option for app event/notification event (like WiFi and Bluetooth) (aka "Not in front/Not connected")
[ ] Set min and max CPU frequency
[ ] Open a website with profile
[x] once and never again event (creatable with an additional button in starter, only start time, end time, start battery, gets deleted after end)
[ ] toggle torch
[ ] profile/event search
[ ] "change wallpapper"->live wallpappers
[ ] Persistent profile/event: sets its options every x minutes
[ ] Android Wear support?
[ ] (AND, OR, XOR, NOT. Or at least NOT.)<-NOT is already available in most preferences. If that stays, that does the same.
[ ] a plugin system? (very small core app, ability to install additional event preferences, maybe only time event preinstalled)
[ ] PP&PPP for PC?

------------------------

System.Settings:
notifications_use_ring_volume ---+--> ze by na odlinkovanie zvonenia a notifikacii?
unlink_volumes_together ---------+
mute_streams_affected
mode_ringer_streams_affected

System.Global:
heads_up_notifications_enabled


Ako disablovat lockscreen, 2 kroky:
1. nastavit, ze power tlacitko nema lockovat
  /data/system/locksettings.db - lockscreen.power_button_instantly_locks (0,1)
  len je otazka, ci toto existuje aj na starsich androidoch ako 5.0
2. nastavit lockscreen timeout 
  Settings.Secure - lock_screen_lock_after_timeout (milisekundy)


--------

4. sprav notifikaciu ako dasboard, kde budu ikony profilov, klikom na ikonu sa profil aktivuje.
   poradie bude take iste ako pro aktivatore. Ak sa nezmestia na jednu notifikaciu, spravit dalsiu.
   Notifikacia bude mat prioritu nastavitelnu, default bude Minimal. Uzivatel si bude moct zmenit, aby sa
   takat notifikacia zobrazila aj v lockscreene. ;-)

--------

---------- PIN/password

1. ako zrusim pin/heslo

deviceManager.setPasswordMinimumLength(compName, 0);
boolean result = deviceManager.resetPassword("", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);

2. ako nahodim pin/heslo

DevicePolicyManager deviceManager = (DevicePolicyManager)getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName compName = new ComponentName(MessageService.this, LockAdmin.class);  

boolean active = deviceManager.isAdminActive(compName);  

if (active) { 
  deviceManager.setPasswordQuality(compName,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
  deviceManager.setPasswordMinimumLength(compName, 5);

  boolean result = deviceManager.resetPassword("blablabla", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);
}

3. password quality:

DevicePolicyManager.PASSWORD_QUALITY_SOMETHING - pattern lock?
DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK - tvar, odtlacok prstu?
DevicePolicyManager.PASSWORD_QUALITY_NUMERIC - pin?
DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_COMPLEX - heslo?

--------------------------------

NFC tag senzor - NEFUNGUJE PRI CITANI TAGU NA POZADI!

Tu mas ako sa to id cita: https://gist.github.com/luixal/5768921.

- Sprav aby to len citalo UID a to pouzivaj na identifikaciu tagu.
  Takto precitas UID: https://gist.github.com/luixal/5768921
- Na nacitanie tagu v NFCTagPreference sa vytvori nova aktivita NFCTagReadEditorActivity.
  Ta bude normalna ako je teraz NFCTagWritreActivity, ktoru zahodim.
  Zobrazovat bude precitane UID tagu a aj jeho obsah.
  Aj citanie by malo zacat automaticky, ked prilozim tag ku mobilu.
- Pridanie tagu nech hned vyvola citanie UID
- Write to tag polozku menu tagu zrus a zamen za citanir UID tagu
- Premenovanie tagu teraz je nahovno, nespravi aj zapis dso tagu, ale po novom to bude OK ako to je.
- V tabulke TABLE_NFC_TAGS pribudne polozka KEY_NT_UID = "uid". Tam sa zapise precitane uid.
- Aby bola spatna kompatibilita so starymi tagmi, bude NFCTagReadActivity citat uid aj obsah tagu.
  Ak bude uid v tabulke KEY_NT_UID prazdne, pouzije sa ako teraz obsah tagu. Inac sa pouzije uid tagu.
- Pre NFCTagReadActivity zmenit v manifeste intent filter na tento:
    <intent-filter>
        <action android:name="android.nfc.action.TAG_DISCOVERED"/>
        <category android:name="android.intent.category.DEFAULT"/>
      </intent-filter>

----------------------

Direct boot:
- Asi nemozem spravit, nepodporuje to WorkManager. :-(
- toto je super na to, aby sa PPP startol aj pri uzamknutej obrazovke.
- android.intent.action.LOCKED_BOOT_COMPLETED vid:
    https://medium.com/@jordan_shifter/direct-boot-on-android-nougat-71f06c4a7c9e
- Ak nepuzijes direct boot, tak apka pada napr. v Fabric, android_job.
  To preto, lebo chcu pouzivat shared preferences a v uzamknutej obrazovke bez direct boot
  to spadne na IllegalStateException.
- Ako spravit podporu Direct boot:
    https://developer.android.com/training/articles/direct-boot
- Len mam taky strasne blby pocit, ze prave Fabric, android_job bude problem. neviem ako movnut
  shared preferences z device do credential storage. Nepoznam nazvy shared preferences a
  databazy.
  Vid:
    https://developer.android.com/reference/android/content/Context#moveSharedPreferencesFrom(android.content.Context,%20java.lang.String)
    https://developer.android.com/reference/android/content/Context#moveDatabaseFrom(android.content.Context,%20java.lang.String)
  Alebo, ze by pomohlo toto?
    https://stackoverflow.com/questions/51377089/android-crashlytics-fails-on-direct-boot-due-to-disk-encryption

----------------------------------------------

Android Q beta 1 - emulator:

2019-03-15 19:40:37.496 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: java.io.FileNotFoundException: /system/build.prop: open failed: EACCES (Permission denied)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.IoBridge.open(IoBridge.java:496)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.io.FileInputStream.<init>(FileInputStream.java:159)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.isMIUI(PPApplication.java:1945)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.<clinit>(PPApplication.java:59)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.lang.Class.newInstance(Native Method)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.AppComponentFactory.instantiateApplication(AppComponentFactory.java:62)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.support.v4.app.CoreComponentFactory.instantiateApplication(CoreComponentFactory.java:49)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.Instrumentation.newApplication(Instrumentation.java:1144)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.LoadedApk.makeApplication(LoadedApk.java:1211)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6144)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.access$1100(ActivityThread.java:208)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1769)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.os.Handler.dispatchMessage(Handler.java:106)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.os.Looper.loop(Looper.java:209)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:7021)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.lang.reflect.Method.invoke(Native Method)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:486)
2019-03-15 19:40:37.522 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:872)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: Caused by: android.system.ErrnoException: open failed: EACCES (Permission denied)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.Linux.open(Native Method)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.ForwardingOs.open(ForwardingOs.java:167)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.BlockGuardOs.open(BlockGuardOs.java:237)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.IoBridge.open(IoBridge.java:482)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: 	... 17 more
2019-03-15 19:40:37.524 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: java.io.FileNotFoundException: /system/build.prop: open failed: EACCES (Permission denied)
2019-03-15 19:40:37.524 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.IoBridge.open(IoBridge.java:496)
2019-03-15 19:40:37.524 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.io.FileInputStream.<init>(FileInputStream.java:159)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.getEmuiRomName(PPApplication.java:1969)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.isEMUI(PPApplication.java:1990)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.<clinit>(PPApplication.java:60)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.lang.Class.newInstance(Native Method)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.AppComponentFactory.instantiateApplication(AppComponentFactory.java:62)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.support.v4.app.CoreComponentFactory.instantiateApplication(CoreComponentFactory.java:49)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.Instrumentation.newApplication(Instrumentation.java:1144)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.LoadedApk.makeApplication(LoadedApk.java:1211)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6144)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.access$1100(ActivityThread.java:208)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1769)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.os.Handler.dispatchMessage(Handler.java:106)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.os.Looper.loop(Looper.java:209)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:7021)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.lang.reflect.Method.invoke(Native Method)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:486)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:872)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: Caused by: android.system.ErrnoException: open failed: EACCES (Permission denied)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.Linux.open(Native Method)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.ForwardingOs.open(ForwardingOs.java:167)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.BlockGuardOs.open(BlockGuardOs.java:237)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.IoBridge.open(IoBridge.java:482)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: 	... 18 more

------------------------------------------------------------------------

Permissions vz. Root/G1

checkProfileVibrationOnTouch(context, profile, permissions);
_vibrationOnTouch

checkProfileVibrateWhenRinging(context, profile, permissions);
_vibrateWhenRinging (R)

checkProfileRingtones(context, profile, permissions);
_soundRingtoneChange
_soundNotificationChange
_soundAlarmChange

checkProfileScreenTimeout(context, profile, permissions);
_deviceScreenTimeout

checkProfileScreenBrightness(context, profile, permissions);
getDeviceBrightnessChange() (R)

checkProfileAutoRotation(context, profile, permissions);
_deviceAutoRotate

checkProfileNotificationLed(context, profile, permissions);
_notificationLed (R)

checkProfileWallpaper(context, profile, permissions);
_deviceWallpaperChange

checkProfileRadioPreferences(context, profile, permissions);
_deviceWiFiAP (R)
_deviceBluetooth
_deviceMobileData (R)
_deviceNetworkType (R)
_deviceConnectToSSID

checkProfilePhoneBroadcast(context, profile, permissions);
_volumeSpeakerPhone

checkCustomProfileIcon(context, profile, permissions);
getIsIconResourceID()

checkProfileAccessNotificationPolicy(context, profile, permissions);
_volumeRingerMode

checkProfileLockDevice(context, profile, permissions);
_lockDevice (R)

checkProfileDtmfToneWhenDialing(context, profile, permissions);
_dtmfToneWhenDialing

checkProfileSoundOnTouch(context, profile, permissions);
_soundOnTouch

----------------------------------------

Optimalizacia Editora a priprava na ViewPager:

- Mozes pre Editor pouzit pre profily jeden jediny layout. Lisia sa len indikatorom v headeri.
  Ten mozes krasne schovavat, ak su vypnute indikatory
- Potom uz nie je problem vytvorit jeden jediny fragment pre profily a jeden jediny pre udalosti.
  Netreba pri zmene fiktra vytvarat nanovo cely fragment.
  Na zmenu filtra len do prislusneho fragmentu posles nove parametre, ktore teraz davas ago argumenty pri vytvarani fragmentu.
- Ked toto budes mat, nebude sa pri kasdej zmene filtra znova nacitatavat zoznam profilov a udalosti z databazy.
  Lebo adapter ich filtruje sam, podla nastaveneho filtra v aktivite.
  Treba akurat vyriesit zmenu poradia profilov a udalosti.
  Totizto v AsyncTasku ich sortujem.
- Potom bude omnoho jednoduchsie spravit ten ViewPager pre Editor.

----------------------------------------

- Dostupnost: cize Accessibility service - bud PPP zobrazuje hned v zozname alebo treba kliknut na "Nainstalovane sluzby".
  Tam treba najst "PhoneProfilesPlusExtender" a povolit ho.
- System nastavenia polohy: treba povolit pouzivanie polohy.
- Pristup k upozrneniam: treba najst v zozname "PhoneProfilesPlus" a povolt ho.
- Optimalizacia baterie: Treba hore prepnut na "Vsetky", najst "PhoneProfilesPlus" a zakazat ho. Aby neoptimalizoval.
- Setric baterie: toto pozri na Nexuse, mne to preplo na "Rezim vykonu". Tam nic nemenim.
  Ktohovie, co sa zobrazuje pri inych mobiloch. Testni.
- Povolenie "Uprava nastaveni systemu": Zobrazi sa priamo pre PPP. Cize netreba dialog.
- Povolenie "Pristup k nastaveniu Nerusit": Treba najst "PhoneProfilesPlus" a povolit ho.
- Povolenie "Vykreslit cez dalsie apliakcie": Zobrazi sa priamo pre PPP. Cize netreba dialog.
- Povolenia pre aplikaciu: ak to je z nastaveni profilu/udalosti, netreba robit nic. Ak je to Nastavenia aplikacie,
  treba kliknut na "Opravnenia" a tam povolit prislusne opravnenia.
- Stavovy riadok - Systemove nastavenia: otvori nastavenia kanala "Aktivovany profil". Tu nech si nastavi to, co potrebuje.

Totot vypada, ze je to vsetko, ale odporucam pozriet v kode, co je vsetko volane.
Pozri kedy je to volane (Android verzia) a hladaj to v nastaveniach systemu.

Hladaj: R.string.setting_screen_not_found_alert

--------------------------------------

!!! Treba testovat, ci je elapsedTime zaporny. Ak je, daj work bez setInitialDelay().
!!! TimeChangedReceiver - by mali byt spravene cez restartEvents, co je tam uz volany.
- DonationBroadcastReceiver -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- TwilightScanner -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- EventPreferencesTime -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- EventPreferencesAlarmClock -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- EventPreferencesCalendar -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- EventPreferencesCall -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- EventPreferencesSMS -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- EventPreferencesNFC -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- EventPreferencesNotification -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO

Tieto maju od uzivatela parameter duration, delay:
- Event.setDelayStartAlarm -> cas od now() + delay, pouziva aj AlarmClock
HOTOVO
- Event.setDelayEndAlarm -> cas od now() + delay, pouziva aj AlarmClock
HOTOVO
- ProfileDurationAlarmBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock
HOTOVO
- RunApplicationWithDelayBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock
HOTOVO
- StartEventNotificationBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock
HOTOVO

Tento sa pouziva na spracovanie udalosti na screen off ale az po jeho loknuti:
- LockDeviceAfterScreenOffBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock,
uzivatel moze zadat interval, ale len v device Settings.
HOTOVO

Tento sa pouziva na prepinanie GPS on/off:
- GeofencesScannerSwitchGPSBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock, uzivatel nemoze
zadat interval, je natvrdo 1 alebo 30 minut, podla toho, ci sa ma pouizvat GPS. Toto je kandidat na WorkManagera.
HOTOVO

Tento sa pouziva na zavretie lock device aktivity:
- LockDeviceActivityFinishBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock,
uzivatel nemoe zadat interval, je natvrdo 20 sekund. Toto ma sledovat, ci uzivatel vypol obrazovku
a ked nie, ma sa LockDeviceActivity zavriet. Toto je kandidat na WorkManagera.
HOTOVO

--------------------------------------

https://mail.google.com/mail/u/0/#inbox/FMfcgxwGCGzLSzHXNSXxmMFsKjrPZZMT
Pozri, cele je to v implementation 'com.google.firebase:firebase-analytics:17.2.1'
Musia to upgradnut, inac ho budem musiet vyhodit.

--------------------------------------

Extender:
- Skus spravit tak, ze zavolas Intent na download apk. V URL je cislo verzie, ale typu 5.1.2.1.
  Cize toto by som musel pouzivat v PPP.
- Ako stiahnut apk:
  https://stackoverflow.com/questions/48130430/download-a-file-in-background-without-opening-browser-with-intent
  https://stackoverflow.com/questions/525204/android-download-intent
- Testni to a zisti, co sa stane, ked kilknes na tu notifikaciu po stiahnuti.
- Hlavne pozri na nazov apk po stiahnuti. Ci tam neda cislo, napr. (1), (2) atd.
- Kliknutie na notifikaciu pos tiahnuti by mala zavolat dalsi Intent na instalaciu apk.
- Tymto by som mal vyriesenu instalaciu Extendera, ci uz noveho alebo upgrade.

- Vypada to, ze parametrov, ktore pouzivaju Extender je stale viac.
- Co tak spravit daky dialog, z ktoreho sa bude dat Extender managovat?
- Aby nemuseli byt pri kazdom profil/event parametri 3 dalsie kvoli Extenderu.
- Pridaj dakde v Editore daku indikaciu, ze je Extender vyzadovany v novej verzii.
  Nieco uz o tom mas v Important info, notifikacia o tom sa zobrazi po upgrade PPP.

- Zatial pridaj aspon upozornenie, ze je stary Extender. Mozno to uz mam, kukni.
  Sprav to ako pri pravach a podobne. Pis aj verziu, ktora je vyzadovana.

Kde je treba Extender:

Profily:
- Force stop application
- Lock device

Eventy:
- Call sensor
- SMS/MMS sensor
- Application sensor
- Orientation sensor

----------------------------------------

Pozri, ci pre Bluetooth vyzadujes pravo Write system settings. Vraj to moze vypnut ten otravny dialog pre Bluetooth. Huawei mobily.

----------------------------------------

RINGERMODE_RING : dnd = ZENMODE_ALL, ringerMode = AudioManager.RINGER_MODE_NORMAL
RINGERMODE_RING_AND_VIBRATE : dnd = ZENMODE_ALL, ringerMode = AudioManager.RINGER_MODE_NORML
RINGERMODE_VIBRATE : dnd = ZENMODE_ALL, ringerMode = AudioManager.RINGER_MODE_VIBRATE
RINGERMODE_SILENT : dnd = ZENMODE_SILENT, ringerMode = AudioManager.RINGER_MODE_SILENT ???
RINGERMODE_ZENMODE:
- ZENMODE_ALL : ringerMode = profile._ringerModeForZenMode
- ZENMODE_PRIORITY : ringerMode = profile._ringerModeForZenMode
- ZENMODE_NONE : ZENMODE_ALL, ringerMode = -1 + 1000sec + ZENMODE_NONE, ringerMode = profile._ringerModeForZenMode
- ZENMODE_ALL_AND_VIBRATE : ZENMODE_ALL + ringerMode = AudioManager.RINGER_MODE_VIBRATE
- ZENMODE_ALL_PRIORITY_VIBRATE : ZENMODE_PRIORITY + ringerMode = AudioManager.RINGER_MODE_VIBRATE
- ZENMODE_ALARMS : ZENMODE_ALL, ringerMode = -1 + 1000sec + ZENMODE_ALARMS, ringerMode = profile._ringerModeForZenMode ???


----------------------------------------

Do shared preferences zapisuje aj:

Toto je o tom, ci na start zobrazovat notifikaciu Important info. Zatial necham tak.
- ImportantInfoNotification.PREF_SHOW_INFO_NOTIFICATION_ON_START
- ImportantInfoNotification.PREF_SHOW_INFO_NOTIFICATION_ON_START_VERSION

Tu si pamatam, ci ide o prvy start. Volane ak chcem zobrazit Quick guide. Zatial nechat tak.
- LauncherActivity - ApplicationPreferences.PREF_APPLICATION_FIRST_START

Toto je volane, ked sa zmeni verzia apliakcie. Nechat v shared preferences.
- PPApplication.PREF_SAVED_VERSION_CODE

Toto je pre autoregistraciu, Nechat v shared preferences.
- MobileCellsRegistrationService.PREF_MOBILE_CELLS_AUTOREGISTRATION_DURATION
- MobileCellsRegistrationService.PREF_MOBILE_CELLS_AUTOREGISTRATION_CELLS_NAME
- MobileCellsRegistrationService.PREF_MOBILE_CELLS_AUTOREGISTRATION_ENABLED
- MobileCellsRegistrationService.PREF_MOBILE_CELLS_AUTOREGISTRATION_REMAINING_DURATION

Toto je pre donation notifikaciu generovanu na pozadi. Volane raz denne, nechat v shared preferences.
- PPApplication.PREF_DAYS_AFTER_FIRST_START
- PPApplication.PREF_DONATION_NOTIFICATION_COUNT
- PPApplication.PREF_DAYS_FOR_NEXT_DONATION_NOTIFICATION
- PPApplication.PREF_DONATION_DONATED



Toto dat ku ostatnym ApplicationPreferences, cize dat aj ako staticke premenne.
- EditorProfilesActivity - ApplicationPreferences.PREF_APPLICATION_EVENT_NEVER_ASK_FOR_ENABLE_RUN
- EditorProfilesActivity - ApplicationPreferences.PREF_APPLICATION_NEVER_ASK_FOR_GRANT_ROOT
HOTOVO

Toto dat ku ostatnym aplikacnym parametrom, cize dat aj ako staticke premenne. Podobne ako ApplicationPreferences.
- EventsPrefsActivity - ApplicationPreferences.PREF_APPLICATION_EVENT_NEVER_ASK_FOR_ENABLE_RUN
HOTOVO

Toto dat ku ostatnym aplikacnym parametrom, cize dat aj ako staticke premenne. Podobne ako ApplicationPreferences.
- ExitApplicatiinActivity - ApplicationPreferences.PREF_APPLICATION_EVENT_NEVER_ASK_FOR_ENABLE_RUN
- ExitApplicatiinActivity - ApplicationPreferences.PREF_APPLICATION_NEVER_ASK_FOR_GRANT_ROOT
HOTOVO

Toto dat ku ostatnym aplikacnym parametrom, cize dat aj ako staticke premenne. Podobne ako ApplicationPreferences.
- Permissions - ApplicationPreferences.PREF_APPLICATION_NEVER_ASK_FOR_GRANT_ROOT
HOTOVO



Toto je volane z Editora, pamata si to pohlad editora. Dat ako static premenne. Podobne ako ApplicationPreferences.
- EditorEventListFragment.SP_EDITOR_ORDER_SELECTED_ITEM
HOTOVO

Toto je volane z Editora, pamata si to pohlad editora. Dat ako static premenne. Podobne ako ApplicationPreferences.
- EditorProfilesActivity.SP_EDITOR_SELECTED_VIEW
- EditorProfilesActivity.SP_EDITOR_PROFILES_VIEW_SELECTED_ITEM
- EditorProfilesActivity.SP_EDITOR_EVENTS_VIEW_SELECTED_ITEM
HOTOVO



Toto je volane aktivaciou profilu. Dat ako static premenne. Podobne ako ApplicationPreferences.
- ActivatedProfileHelper.PREF_RINGER_VOLUME
- ActivatedProfileHelper.PREF_NOTIFICATION_VOLUME
- ActivatedProfileHelper.PREF_RINGER_MODE
- ActivatedProfileHelper.PREF_ZEN_MODE
- ActivatedProfileHelper.PREF_LOCKSCREEN_DISABLED
- ActivatedProfileHelper.PREF_ACTIVATED_PROFILE_SCREEN_TIMEOUT
HOTOVO

Toto je volane aktivaciou profilu. Dat ako static premenne. Podobne ako ApplicationPreferences.
- ActivatedProfileHelper.PREF_MERGED_RING_NOTIFICATION_VOLUMES
HOTOVO

Toto je volane aktivaciou profilu. Dat ako static premenne. Podobne ako ApplicationPreferences.
- Profile.PREF_ACTIVATED_PROFILE_FOR_DURATION
- Profile.PREF_ACTIVATED_PROFILE_END_DURATION_TIME
HOTOVO



Tu si pamatam, ci zobrazovat notifikaciu o optimalizacii baterie. Dat ako static premenne. Podobne ako ApplicationPreferences.
- IgnoreBatteryOptimizationNotification.PREF_SHOW_IGNORE_BATTERY_OPTIMIZATION_NOTIFICATION_ON_START
HOTOVO

Toto je volane casto. Casto sa zapisuje log. Dat ako static premenne. Podobne ako ApplicationPreferences.
- PPApplication.PREF_ACTIVITY_LOG_ENABLED
HOTOVO

Toto sa meni casto kvoli meneniu nazvu aktivovaneho profilu. Dat ako static premenne. Podobne ako ApplicationPreferences.
- PPApplication.PREF_NOTIFICATION_PROFILE_NAME
- PPApplication.PREF_WIDGET_PROFILE_NAME
- PPApplication.PREF_ACTIVITY_PROFILE_NAME
- PPApplication.PREF_LAST_ACTIVATED_PROFILE
HOTOVO



Toto je volane z udalosti, pamata si v ako stave je spustenie udalosti. Dat ako static premenne. Podobne ako ApplicationPreferences.
- Event.PREF_EVENTS_BLOCKED
- Event.PREF_FORCE_RUN_EVENT_RUNNING
HOTOVO

Toto je pre zapis aplikacie, ktora je na pozadi. Volane casto. Dat ako static premenne. Podobne ako ApplicationPreferences.
- PPPExtenderBroadcastReceiver.PREF_APPLICATION_IN_FOREGROUND
HOTOVO


Toto je volane z udalosti, senzor hovoru. Pamatam si tu kto, kedy volal a v ako stave je hovor. Dat ako static premenne.
Podobne ako ApplicationPreferences.
- EventsHandler - EventPreferencesCall.PREF_EVENT_CALL_EVENT_TYPE
- EventsHandler - EventPreferencesCall.PREF_EVENT_CALL_PHONE_NUMBER
- EventsHandler - EventPreferencesCall.PREF_EVENT_CALL_EVENT_TIME
HOTOVO

Toto je volane z udalosti, senzor hovoru. Pamatam si tu kto, kedy volal a v ako stave je hovor. Dat ako static premenne.
Podobne ako ApplicationPreferences.
- PhoneProfilesService - EventPreferencesCall.PREF_EVENT_CALL_EVENT_TYPE
- PhoneProfilesService - EventPreferencesCall.PREF_EVENT_CALL_PHONE_NUMBER
- PhoneProfilesService - EventPreferencesCall.PREF_EVENT_CALL_EVENT_TIME
HOTOVO

Toto je volane z udalosti, senzor prislusenstva. Pamatam si tu ake prislusenstvo je pripojene. Dat ako static premenne.
Podobne ako ApplicationPreferences.
- HeadsetConnectionBroadcastReceiver.PREF_EVENT_WIRED_HEADSET_CONNECTED
- HeadsetConnectionBroadcastReceiver.PREF_EVENT_WIRED_HEADSET_MICROPHONE
- HeadsetConnectionBroadcastReceiver.PREF_EVENT_BLUETOOTH_HEADSET_CONNECTED
- HeadsetConnectionBroadcastReceiver.PREF_EVENT_BLUETOOTH_HEADSET_MICROPHONE
HOTOVO

Toto je volane z wifi skenera. Volane casto. Dat ako static premenne. Podobne ako ApplicationPreferences.
- WifiBluetoothScanner.PREF_FORCE_ONE_WIFI_SCAN
- WifiBluetoothScanner.PREF_FORCE_ONE_BLUETOOTH_SCAN
- WifiBluetoothScanner.PREF_FORCE_ONE_LE_BLUETOOTH_SCAN
HOTOVO

Toto je volane z bluetooth skenera. Volane casto. Dat ako static premenne. Podobne ako ApplicationPreferences.
- BluetoothScanWorker.PREF_EVENT_BLUETOOTH_SCAN_REQUEST
- BluetoothScanWorker.PREF_EVENT_BLUETOOTH_LE_SCAN_REQUEST
- BluetoothScanWorker.PREF_EVENT_BLUETOOTH_WAIT_FOR_RESULTS
- BluetoothScanWorker.PREF_EVENT_BLUETOOTH_WAIT_FOR_LE_RESULTS
- BluetoothScanWorker.PREF_EVENT_BLUETOOTH_SCAN_KILLED
- BluetoothScanWorker.
HOTOVO

Toto je volane z wifi skenera. Volane casto. Dat ako static premenne. Podobne ako ApplicationPreferences.
- WifiScanWorker.PREF_EVENT_WIFI_SCAN_REQUEST
- WifiScanWorker.PREF_EVENT_WIFI_WAIT_FOR_RESULTS
- WifiScanWorker.
HOTOVO

Target helps
HOTOVO

------------------------------------------------

EditorProfilesActivity.redrawProfileListFragment()
 - co tak sem zapisat do lokalnej premennej aktivity:
   - scrollToProfile = profile;
 - EditorProfilesActivity.selectFilterItem()
   - EditorProfileListFragment.changeFragmentFilter()
     - EditorProfileListFragment.doOnViewCreated(), fromOnViewCreated=false
       - tu citat EditorProfilesActivity.scrollToProfile
         - ak != null, odscrolovat do neho, vid EditorProfileListFragment.updateListView
           musis zistit, kde ten profil je, lebo zoznam sa kompletne zmenil
           - dorob do DataWraper int getProfilePosition(Profile)
         - nastavit na null
HOTOVO
- EditorProfilesActivity.redrawEventListFragment()
 - co tak sem zapisat do lokalnej premennej aktivity:
   - scrollToEvent = event;
   - EditorEventListFragment.changeFragmentFilter()
     - EditorEventListFragment.doOnViewCreated(), fromOnViewCreated=false
       - changeEventOrder(), fromOnViewCreated=false
         - changeListOrder(), fromOnViewCreated=false
           - tu citat EditorProfilesActivity.scrollToEvent
             - ak != null, odscrolovat do neho, vid EditorEventListFragment.updateListView
               musis zistit, kde ta udalost je, lebo zoznam sa kompletne zmenil
               - dorob do DataWraper int getEventPosition(Event)
             - nastavit na null
HOTOVO

//---------------------------------------

Default profile sa aktivuje ked:
- sa ide spravit manualny restart udalosti. skontoluj, ci naozaj len pri nom, ze kedy sa robi full restart
- nesedi posledne aktivovany profil s tym, co idem aktivovat
Staci, ked plati jedno z toho

Co sa posledne aktivovalo zapisuje DataWrapper._activateProfile cez Profile.saveProfileToSharedPreferences()

Full restart sa robi, ked senzorType = SENSOR_TYPE_RESTART_EVENTS
Cize ked je volane DataWrapper._restartEvents() s unblockEventRun = true.
Cize:
- ActionForExternalApplicationAcivity s ACTION_RESTART_EVENTS
- DataWrapper.restartEventWithAlert()
  - ActivateProfileActivity.onOptionsItemSelected()
  - BackgroundActivateProfileActivity() - pre STARTUP_SOURCE_WIDGET a STARTUP_SOURCE_SHORTCUT
  - EditorProfileActivity.onOptionsItemSelected()
  - RestartEventsFromNotificationActivity - onOptionsItemSelected()
- PhoneProfilesService.doCommand s EXTRA_RESTART_EVENTS - tu je to ako parameter EXTRA_UNBLOCK_EVENTS_RUN, nie natvrdo
  - PPApplication.restartEvents() - tu je to ako parameter
    - PhoneProfilesPrefsActivity.doPreferenceChanged() - !!! TU SA NELOGUJE !!!
- RestartEventsWithDelayWorker - tu je to ako parameter EXTRA_UNBLOCK_EVENTS_RUN, nie natvrdo
  - DataWrapper.restartEventsWithDelay() - tu je to ako druhy parameter
    - Event.doActivateEndProfile() - ak je na koniec udalosti nakonfigurovane EATENDDO_RESTART_EVENTS
    - ProfileDurationAlarmBroadcastReceiver() - ak je na koniec trvania profilu nakonfigurovane AFTER_DURATION_DO_RESTART_EVENTS
- TimeChangedReceiver - ak nie je manualne aktivovany profil - tu pozri, kedy toto bolo robene, ale zda sa mi, ze to este na Google Play nie je.

Bez logu o restarte je:
- PhoneProfilesService.doCommand s EXTRA_RESTART_EVENTS - tu je to ako parameter EXTRA_UNBLOCK_EVENTS_RUN, nie natvrdo
  - PPApplication.restartEvents() - tu je to ako parameter
    - PhoneProfilesPrefsActivity.doPreferenceChanged() - !!! TU SA NELOGUJE !!!

------------------------------

Tu je volany ten HandlerThread
1. PhoneProfilesService.startListeningOrientationSensors()
2. OrientationScanner.onSensorChanged() - zisti, aky thread to pouziva
3. DatatWrapper.doHandleEvents()

PhoneProfilesService.startListeningOrientationSensors()
- PhoneProfilesService.startOrientatonScanner(...)
  Tu sa aj inicializuje OrientationScanner

OrientationScanner.onSensorChanged()
- toto je ok, vola to system, nikde inde toto volane byt nemoze a nie je

DatatWrapper.doHandleEvents()
- EventsHandler.handleEvents()

---

PhoneProfilesService.startOrientatonScanner(...)
- PhoneProfilesService.registerReceiversAndWorkers()
- PhoneProfilesService.unregisterReceiversAndWorkers()
- PhoneProfilesService.reregisterReceiversAndWorkers()
- PhoneProfilesService.doCommand()

---

EventsHandler.handleEvents()
- volane strasne vela krat zaujima ma restart udalosti a samotny orientacny senzor
- SENSOR_TYPE_DEVICE_ORIENTATION
  - z OrientationScanner.runEventsHandlerForOrientationChange() - zisti, aky thread to pouziva
  - z PPPExtenderBroadcastRecveiver.onReceive() - je to volane v HandlerThread - vroadcast treba, lebo senzor sleduje aplikacie na popredi

--------------------------------------------

-- elapsed

try {
    WorkManager workManager = WorkManager.getInstance(_context);
    //workManager.cancelUniqueWork("elapsedAlarmsEventDelayStartWork_"+((int) this._id));
    workManager.cancelAllWorkByTag("elapsedAlarmsEventDelayStartWork_"+((int) this._id));
} catch (Exception ignored) {}

"elapsedAlarmsShowProfileNotificationWork" -> ShowProfileNotificationBroadcastyReceiver.removeAlarm()
"elapsedAlarmsUpdateGUIWork" -> UpdateGUIBroadcastReceiver.removeAlarm()

"elapsedAlarmsProfileDurationWork_"+(int)profile._id -> ProfileDurationAlarmBroadcastReceicver.removeAlarm()
"elapsedAlarmsRunApplicationWithDelayWork_"+requestCode -> RunApplicationWithDelayBroadcastReceiver.removeDealyAlarm()

"elapsedAlarmsEventDelayStartWork_"+(int) event._id -> Event.removeDelayStartAlarm()
"elapsedAlarmsEventDelayEndWork_"+(int) event._id -> Event.removeDelayEndAlarm()
"elapsedAlarmsStartEventNotificationWork_"+(int)event._id -> StartEventNotificationBroadcastReceiver.

-- unique
try {
    WorkManager workManager = WorkManager.getInstance(context);
    workManager.cancelUniqueWork("disableInternalChangeWork");
    workManager.cancelAllWorkByTag("disableInternalChangeWork");
} catch (Exception ignored) {}

PhoneProfilesService.cancelWork("disableInternalChangeWork", context);
try {
    WorkManager workManager = WorkManager.getInstance(context);
    workManager.enqueueUniqueWork("disableInternalChangeWork", ExistingWorkPolicy.REPLACE, disableInternalChangeWorker);
} catch (Exception ignored) {}

"disableInternalChangeWork" -> nema
"delayedWorkCloseAllApplications" -> nema
"handleEventsBluetoothLEScannerWork" -> nema
BluetoothScanWorker.WORK_TAG -> BluetoothScanWorker.canceWork()
"handleEventsBluetoothCLScannerWork" -> nema, ale asi by bolor super pridat do BluetoothScanWorker.canceWork()
"restartEventsWithDelayWork" -> nema
GeofenceScanWorker.WORK_TAG -> GeofenceScanWorker.cancelWork()
"elapsedAlarmsGeofenceScannerSwitchGPSWork" -> GeofenceScannerSwitchGPSBroadcastReceiver.removeAlarm()
LocationGeofenceEditorActivity.FETCH_ADDRESS_WORK_TAG -> nema
"elapsedAlarmsLockDeviceFinishActivity" -> LockDeviceActivityFinishBroadcastReceiver.removeAlarm()
"elapsedAlarmsLockDeviceAfterScreenOff" -> nema
"packageReplacedWork" -> nema, aj ked niekde to asi volane je
"delayedWorkAfterFirstStartWork" -> nema, aj ked niekde to asi volane je
"setBlockProfileEventsActionWork" -> nema
SearchCalendarEventsWorker.WORK_TAG -> SearchCalendarEventsWorker.cancelWork()
"handleEventsWifiScannerFromScannerWork" -> nema
"handleEventsWifiScannerFromReceiverWork" -> nema
WifiScanWorker.WORK_TAG -> WifiScanWorker.cancelWork()
"startWifiScanWork" -> nema

-----------------------------------------

BluetoothLEScanCallback21
- BluetoothScanWorker
  - startLEScan()
    WifiBluetoothScanner.bluetoothLEScanner.startScan(filters, settings, new BluetoothLEScanCallback21(context));
    - bluetooth = BluetoothAdapter.getDefaultAdapter(); //getBluetoothAdapter(context);
    - WifiBluetoothScanner.bluetoothLEScanner = bluetooth.getBluetoothLeScanner();

  - stopLEScan()
    WifiBluetoothScanner.bluetoothLEScanner.stopScan(new BluetoothLEScanCallback21(context));
    - bluetooth = BluetoothAdapter.getDefaultAdapter(); //getBluetoothAdapter(context);
    - WifiBluetoothScanner.bluetoothLEScanner = bluetooth.getBluetoothLeScanner();

startLEScan()
- BluetoothStateChangedBroadcastRecdeiver
  - onReceive()
    - HandlerThread.handler.post()
      - BluetoothScanWorker.startLEScan(appContext);
- WifiBluetoothScanner
  - doScan()
    - BluetoothScanWorker.startLEScan(context);

stopLEScan()
- WifiBluetoothScanner
  - waitForLEBluetoothScanEnd()

doScan()
- BluetoothScanWorker
  - startScanner()

startScanner()
- BluetoothPreferenceFragmentX
  - rescanAsyncTask.doInBackground()
- Bluetootk=hScanWorker
  - doWork()

-------------------------------------------------------------

- EventsHandler.handleEvents().reactivteProfile - nastavi sa na true ak ide o restart udalosti. Pre predvoleny profil sa robi tvrdy restart
  Vtedy sa profil aj aktivuje A TO VZDY A TO JE CHYBA LEBO:
                if (profileChanged || reactivateProfile)
  A toto teda sposobuje, ze sa zaloguje aktivacia a aj sa naozaj aktivuje predvoleny profil. Cize by reactivateProfile nemal pouzivat.
  Teda nech sa aktivuje naozaj len ak sa nieco zmeni v partametroch mergnuteho profilu.
  Udalosti nech sa kludne restartuju.

- Cize kukni, kedy vlastne sa robi ten tvrdy restart a zaroven sa nezaloguje.

- Makky restart sa spravi, ak:
    if ((ApplicationPreferences.prefEventsBlocked && (!unblockEventsRun))

- Restart sa nazaloguje, ak log = false
- Cize najprv zisti, kedy je unblockEventsRun = false
  - DataWrapper.startEventsOnBoot() - log vtedy nerobi a ani tvrdy restart, teda ak ApplicationPreferences.prefEventsBlocked = true
  - TimeChangeReceiver.doWork() - log vtedy nerobi a ani tvrdy restart, teda ak ApplicationPreferences.prefEventsBlocked = true


DataWrapper.startEventsOnBoot()
- DataWrapper.firstStartEvents()
-- Vola restartEventsWithRescan(false, ???, false, false) ak ma zapnute ApplicationPreferences.applicationStartEvents
   - cize unblockEventsRun = false
   - Zavola sa _restartEventsWithRescan(false, false);
     - zavola sa restartEvents(false, false);
       - zavola sa _restartEvents(false, false)
         - unblockEventsRun je sice false, ale ziadna udalost nie je blokovana
           - zavola sa EventsHandler.handleEvents() s SENSOR_RESTART_EVENTS
             cize sa robi tvrdy restart udalosti. Ten sa teda robi pre kazde volanie DataWrapper.firstStartEvents()
             ak nebezi ziadna udalost, tak 100%, cize pre predvoleny profil tiez 100%

-- Inac vypne global events run a vola activateProfileOnBoot()

TimeChangeReceiver.doWork()
- TimeChangeReceiver.onReceive()

DataWrapper.firstStartEvents()
- BootupReceiver.onReceive()

- DelayedWorksWorker.doWork() = pre DELAYED_WORK_PACKAGE_REPLACED
  - PackageReplacedReceiver.onReceive()
  - DataWrapper.doForFirstStart()

- PhoneProfilesService.doForFirstStart()
  - DatatWrapper.pauseAllEvents(false, false) - !!! Co toto robi? Sa mi zda, ze tu by mohlo zapisat aktivaciu profilu, teda ak sa tu merguju
    Vypada to tak, ze nerobi nic, kedze ziadna udalost nebezi a oba partametre su false.

---------------

Nativna notifikacia:

API level < 24 nema dekorator, tak pre ne nedovol nastavit velkost.
API level >= 24 ma dekorator, dovol nastavit zobrazovanie ikony profilu
Pouzivaj to len ak je typ native, inac to zakaz.
Cize pridaj novy parameter pre zobrazovanie ikony. Nech to je switch.

----------------

Full restart udalosti:
- prechadza vsetky udalosti jednu za druhou v opacnom poradi startu
- pauzuje len to co bezi, lebo nema co ine pauzovat
- potom prechadza vsetky udalosti jednu za druhou v poradi startu
- spusta to co spustit ma
Na TimeChangedReceiver spravi tzv. ciastocny restart, kde nezrusi manualne aktivovany profil, ktory blokuje udalosti.
To preto, aby sa nezmenil stav. Proste, ked je manualna aktivacia, tak sa udalosti neodblokuju. Teda okrem tych, co
maju _forceRun = true. Pre ne sa blokovanie ignoruje, spustia sa.
Kedy sa blokuju udalosti:
- blokuje sa, ak sa profil aktivuje manualne
Len restart udalosti vie odblokovat ich beh. Ma na to parameter. Ide ut o ten full restart.

--------------

Start udalosti:
1. Start s delay nastavi alarm pre SENSOR_TYPE_EVENT_DELAY_START a NENASTAVI event._status na ESTATUS_RUNNING, necha ho ESTATUS_PAUSE
2. Po delay znova testuje, ci sa zmeni stav udalosti a tiez ci event._isInDelayStart je uz false. Az tu vola startEvemt(), cize nastavi ESTATUS_RUNNING.
Vysledok je, ze pocas delay je stale PAUSE az po delay je RUNNING.

Koniec udalosti:
1. Koniec s delay nastavi alarm pre SENSOR_TYPE_EVENT_DELAY_END a NENASTAVI event._status na ESTATUS_PAUSE, necha ho ESTATUS_RUNNING
2. Po delay znova testuje, ci sa zmeni stav udalosti a tiez ci event._isInDelayEnd je uz false. Az tu vola pauseEvemt(), cize nastavi ESTATUS_PAUSE.
Vysledok je, ze pocas delay je stale RUNNING az po delay je PAUSE.

--------------

NextAlarmClockBroadcastReceiver
- AlarmManager.ACTION_NEXT_ALARM_CLOCK_CHANGED
- AlarmManager.AlarmClockInfo alarmClockInfo = alarmManager.getNextAlarmClock();
- long _time = alarmClockInfo.getTriggerTime(); - cas alarmu
- PendingIntent infoPendingIntent = alarmClockInfo.getShowIntent(); - intent alarmu
  ak je null, nahadzujem PhoneProfilesService.ACTION_ALARM_CLOCK_BROADCAST_RECEIVER. Preco???
- String packageName = infoPendingIntent.getCreatorPackage();
  ak je null, nahadzujem PhoneProfilesService.ACTION_ALARM_CLOCK_BROADCAST_RECEIVER. Preco???
  ak to nie je PPP, nahadzujem PhoneProfilesService.ACTION_ALARM_CLOCK_BROADCAST_RECEIVER. OK

Cize v dvoch pripadoch nahadzujem alarm. Vypada to, ze to je blbost. Asi sa snzim podporovat co najviac typov.
Moze to sposobit, ze alarm senzor bude passed aj pri nie-budikoch !!! Toto sa mi zda uplne ze zle.
Ako kua teraz z toho von?
Asi proste, ak neviem, co je to za package, tak to odignorujem. Nebude generovat ten alarm.
A pridam teda tu podporu aplikacii. Bude novy parameter pre multiselect preferences aplikacii, ale
len aplikacii A BEZ PP a PPP. Dufam, ze toto spravit ide.
Potom uz len prejdem zoznam packages, ktore mam v tom parametri.
Zoznam uz interne podporovanych tam necham.

Pridaj aj info preference, ktore zobrazi zoznam interne podporovanych aplikacii:
// com.google.android.deskclock - Google Clock
// com.sec.android.app.clockpackage - Samsung Clock
// com.sonyericsson.organizer - Sony Clock
// com.amdroidalarmclock.amdroid - AMdroid
// com.alarmclock.xtreme.free - Alarm Clock XTreme free
// com.alarmclock.xtreme - Alarm Clock XTreme
// droom.sleepIfUCan - Alarmy (Sleep if u can)
// com.funanduseful.earlybirdalarm - Early Bird Alarm Clock
// com.apalon.alarmclock.smart - Good Morning Alarm Clock
// com.kog.alarmclock - I Can't Wake Up! Alarm Clock
// com.urbandroid.sleep - Sleep as Android
// ch.bitspin.timely - Timely
// com.angrydoughnuts.android.alarmclock - Alarm Klock

--------------

Import dat z PP:

ApplicationPreferences.backup

Toto by este slo spravit cez broadcast ze chcem toto a PP by posielal polzku za polozkou.

Ipprtovat do docasnych preferences, ktore, ak to ziskam vsetko bez chyby, zasa polozku po polozke
zapisem do PPP preferences.

Treba tu pozerat, ci taka polozka existuje v PPP a ci sa nezmenili honoty, cize treba spravit mapovanie
do tych docasnych preferences.

- applicationTheme
- applicationStartOnBoot
- applicationActivate
- applicationUnlinkRingerNotificationVolumes
- applicationForceSetMergeRingNotificationVolumes
- notificationsToast
- notificationStatusBar
- notificationStatusBarPermanent
- notificationStatusBarCancel
- notificationShowInStatusBar
- notificationHideInLockscreen
- notificationLayoutType
- notificationStatusBarStyle
- notificationPrefIndicator
- notificationBackgroundColor
- notificationTextColor
- notificationUseDecoration
- notificationShowButtonExit
- applicationBackgroundProfile
- applicationAlert
- applicationActivatorPrefIndicator
- applicationActivatorHeader
- applicationLongClickActivation
- applicationClose
- applicationActivatorGridLayout
- applicationEditorPrefIndicator
- applicationEditorHeader
- applicationWidgetListPrefIndicator
- applicationWidgetListHeader
- applicationWidgetListGridLayout
- applicationWidgetListBackground
- applicationWidgetListBackgroundType
- applicationWidgetListLightnessB
- applicationWidgetListBackgroundColor
- applicationWidgetListShowBorder
- applicationWidgetListLightnessBorder
- applicationWidgetListRoundedCorners
- applicationWidgetListLightnessT
- applicationWidgetListIconColor
- applicationWidgetListIconLightness
- applicationWidgetListCustomIconLightness
- applicationWidgetOneRowPrefIndicator
- applicationWidgetOneRowBackground
- applicationWidgetOneRowBackgroundType
- applicationWidgetOneRowLightnessB
- applicationWidgetOneRowBackgroundColor
- applicationWidgetOneRowShowBorder
- applicationWidgetOneRowLightnessBorder
- applicationWidgetOneRowRoundedCorners
- applicationWidgetOneRowLightnessT
- applicationWidgetOneRowIconColor
- applicationWidgetOneRowIconLightness
- applicationWidgetOneRowCustomIconLightness
- applicationWidgetIconBackground
- applicationWidgetIconBackgroundType
- applicationWidgetIconLightnessB
- applicationWidgetIconBackgroundColor
- applicationWidgetIconShowBorder
- applicationWidgetIconLightnessBorder
- applicationWidgetIconRoundedCorners
- applicationWidgetIconHideProfileName
- applicationWidgetIconLightnessT
- applicationWidgetIconColor
- applicationWidgetIconLightness
- applicationWidgetIconCustomIconLightness
- applicationShortcutEmblem
- applicationSamsungEdgeHeader
- applicationSamsungEdgeBackground
- applicationSamsungEdgeBackgroundType
- applicationSamsungEdgeLightnessB
- applicationSamsungEdgeBackgroundColor
- applicationSamsungEdgeLightnessT
- applicationSamsungEdgeIconColor
- applicationSamsungEdgeIconLightness
- applicationSamsungEdgeCustomIconLightness

phoneProfilesManager.backup

Toto je databaza. Tu by musel PP ju otvorit a postupne profil za profilom polozku po polozke posielat
broadcastom.
Problem je ze ako. Tych parametrov profilu je mrte vela. Da sa to spravit v cykle, ze profil po profile,
jeho polozku za polozkou.

Ipprtovat do docasnej databazy, ktoru, ak to ziskam vsetko bez chyby, zasa profil po profile,
zapisem do PPP databazy.

Treba tu pozerat, ci taka polozka profilu existuje v PPP a ci sa nezmenili honoty, cize treba spravit mapovanie
do tych docasnych poloziek profilu.

Co sa tyka udalosti: pre ne sa spytaj uzivatela, ci chce udalosti zachovat. Ak odpovie nie, tak
ich vsetky vymazem.

-----------------