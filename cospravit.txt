------------------------
Ak sa spravi reboot, onDestrou PPService nastavi, ze nie je spustena aplikacia.
Takze po boote sa PPService nespusti z PPApplication. Treba cakat na BOOT_COMPLETED.
------------------------
funkční nastavení pro Huawei P30 s Androidem 10 a EMUI 10.

nastavení-aplikace- aplikace-PPP-podrobnosti o spotřebě energie-spouštění aplikací:
Spravovat automaticky - ne
Spravovat ručně 3x ano
-automatické souštění
-sekundární souštění
-Spustit na ozadí
------------------------

Ulohy, ktore su spravene [x] a ktore nie [ ]:
[x] location event (when at point X, radius Y)
[x] app event (when app X is started)
[x] Notification event lasts until notification is gone
[x] expand/shrink event and profile preferences, maybe with a checkbox instead of an arrow and all active preferences are expanded – PPP use Android standard preference screens. Than I can only use subscreens. - Yes! If I understand you right, that was my idea.
[x] profile event (only when profile X is active, can't end event)
[x] notification event
[x] Seconds in profile duration
[x] 5 minutes as settable screen timeout
[ ] Priority Notification Event
[x] Restart events at boot option
[x] Restart events shortcut for launcher
[ ] Normal media volume, headphone media volume, Bluetooth media volume
[ ] Sony's "Stamina" mode as profile preference - skor Power save change senzor
[ ] USB connection to PC as storage device, USB connection to PC as camera, connection to USB stick in accessories parameter for events
[x] Option to delete logs after x days
[ ] Resizable grid in Activator
[ ] option to hide PPP from Launcher
[x] Not started/not shown option for app event/notification event (like WiFi and Bluetooth) (aka "Not in front/Not connected")
[ ] Set min and max CPU frequency
[ ] Open a website with profile
[x] once and never again event (creatable with an additional button in starter, only start time, end time, start battery, gets deleted after end)
[ ] toggle torch
[ ] profile/event search
[ ] "change wallpapper"->live wallpappers
[ ] Persistent profile/event: sets its options every x minutes - asi periodic sensor
[ ] Android Wear support?
[ ] (AND, OR, XOR, NOT. Or at least NOT.)<-NOT is already available in most preferences. If that stays, that does the same.
[ ] a plugin system? (very small core app, ability to install additional event preferences, maybe only time event preinstalled)
[ ] PP&PPP for PC?

------------------------

System.Settings:
notifications_use_ring_volume ---+--> ze by na odlinkovanie zvonenia a notifikacii?
unlink_volumes_together ---------+
mute_streams_affected
mode_ringer_streams_affected

System.Global:
heads_up_notifications_enabled

Ako disablovat lockscreen, 2 kroky:
1. nastavit, ze power tlacitko nema lockovat
  /data/system/locksettings.db - lockscreen.power_button_instantly_locks (0,1)
  len je otazka, ci toto existuje aj na starsich androidoch ako 5.0
2. nastavit lockscreen timeout 
  Settings.Secure - lock_screen_lock_after_timeout (milisekundy)

--------

4. sprav notifikaciu ako dasboard, kde budu ikony profilov, klikom na ikonu sa profil aktivuje.
   poradie bude take iste ako pro aktivatore. Ak sa nezmestia na jednu notifikaciu, spravit dalsiu.
   Notifikacia bude mat prioritu nastavitelnu, default bude Minimal. Uzivatel si bude moct zmenit, aby sa
   takat notifikacia zobrazila aj v lockscreene. ;-)

--------

---------- PIN/password

1. ako zrusim pin/heslo

deviceManager.setPasswordMinimumLength(compName, 0);
boolean result = deviceManager.resetPassword("", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);

2. ako nahodim pin/heslo

DevicePolicyManager deviceManager = (DevicePolicyManager)getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName compName = new ComponentName(MessageService.this, LockAdmin.class);  

boolean active = deviceManager.isAdminActive(compName);  

if (active) { 
  deviceManager.setPasswordQuality(compName,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
  deviceManager.setPasswordMinimumLength(compName, 5);

  boolean result = deviceManager.resetPassword("blablabla", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);
}

3. password quality:

DevicePolicyManager.PASSWORD_QUALITY_SOMETHING - pattern lock?
DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK - tvar, odtlacok prstu?
DevicePolicyManager.PASSWORD_QUALITY_NUMERIC - pin?
DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_COMPLEX - heslo?

--------------------------------

NFC tag senzor - NEFUNGUJE PRI CITANI TAGU NA POZADI!

Tu mas ako sa to id cita: https://gist.github.com/luixal/5768921.

- Sprav aby to len citalo UID a to pouzivaj na identifikaciu tagu.
  Takto precitas UID: https://gist.github.com/luixal/5768921
- Na nacitanie tagu v NFCTagPreference sa vytvori nova aktivita NFCTagReadEditorActivity.
  Ta bude normalna ako je teraz NFCTagWritreActivity, ktoru zahodim.
  Zobrazovat bude precitane UID tagu a aj jeho obsah.
  Aj citanie by malo zacat automaticky, ked prilozim tag ku mobilu.
- Pridanie tagu nech hned vyvola citanie UID
- Write to tag polozku menu tagu zrus a zamen za citanir UID tagu
- Premenovanie tagu teraz je nahovno, nespravi aj zapis dso tagu, ale po novom to bude OK ako to je.
- V tabulke TABLE_NFC_TAGS pribudne polozka KEY_NT_UID = "uid". Tam sa zapise precitane uid.
- Aby bola spatna kompatibilita so starymi tagmi, bude NFCTagReadActivity citat uid aj obsah tagu.
  Ak bude uid v tabulke KEY_NT_UID prazdne, pouzije sa ako teraz obsah tagu. Inac sa pouzije uid tagu.
- Pre NFCTagReadActivity zmenit v manifeste intent filter na tento:
    <intent-filter>
        <action android:name="android.nfc.action.TAG_DISCOVERED"/>
        <category android:name="android.intent.category.DEFAULT"/>
      </intent-filter>

----------------------

Direct boot:
- Asi nemozem spravit, nepodporuje to WorkManager. :-(
- toto je super na to, aby sa PPP startol aj pri uzamknutej obrazovke.
- android.intent.action.LOCKED_BOOT_COMPLETED vid:
    https://medium.com/@jordan_shifter/direct-boot-on-android-nougat-71f06c4a7c9e
- Ak nepuzijes direct boot, tak apka pada napr. v Fabric, android_job.
  To preto, lebo chcu pouzivat shared preferences a v uzamknutej obrazovke bez direct boot
  to spadne na IllegalStateException.

  Fabric, android-job uz nepouzivam, treba testnut s Firebase Crashlytics a WorkManager

- Ako spravit podporu Direct boot:
    https://developer.android.com/training/articles/direct-boot

- Len mam taky strasne blby pocit, ze neviem ako movnut shared preferences z device do credential storage.
  Vid:
    https://developer.android.com/reference/android/content/Context#moveSharedPreferencesFrom(android.content.Context,%20java.lang.String)
    https://developer.android.com/reference/android/content/Context#moveDatabaseFrom(android.content.Context,%20java.lang.String)
  Alebo, ze by pomohlo toto?
    https://stackoverflow.com/questions/51377089/android-crashlytics-fails-on-direct-boot-due-to-disk-encryption

----------------------------------------------

Android Q beta 1 - emulator:

2019-03-15 19:40:37.496 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: java.io.FileNotFoundException: /system/build.prop: open failed: EACCES (Permission denied)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.IoBridge.open(IoBridge.java:496)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.io.FileInputStream.<init>(FileInputStream.java:159)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.isMIUI(PPApplication.java:1945)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.<clinit>(PPApplication.java:59)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.lang.Class.newInstance(Native Method)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.AppComponentFactory.instantiateApplication(AppComponentFactory.java:62)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.support.v4.app.CoreComponentFactory.instantiateApplication(CoreComponentFactory.java:49)
2019-03-15 19:40:37.520 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.Instrumentation.newApplication(Instrumentation.java:1144)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.LoadedApk.makeApplication(LoadedApk.java:1211)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6144)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.access$1100(ActivityThread.java:208)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1769)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.os.Handler.dispatchMessage(Handler.java:106)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.os.Looper.loop(Looper.java:209)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:7021)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.lang.reflect.Method.invoke(Native Method)
2019-03-15 19:40:37.521 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:486)
2019-03-15 19:40:37.522 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:872)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: Caused by: android.system.ErrnoException: open failed: EACCES (Permission denied)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.Linux.open(Native Method)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.ForwardingOs.open(ForwardingOs.java:167)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.BlockGuardOs.open(BlockGuardOs.java:237)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.IoBridge.open(IoBridge.java:482)
2019-03-15 19:40:37.523 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: 	... 17 more
2019-03-15 19:40:37.524 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: java.io.FileNotFoundException: /system/build.prop: open failed: EACCES (Permission denied)
2019-03-15 19:40:37.524 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.IoBridge.open(IoBridge.java:496)
2019-03-15 19:40:37.524 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.io.FileInputStream.<init>(FileInputStream.java:159)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.getEmuiRomName(PPApplication.java:1969)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.isEMUI(PPApplication.java:1990)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at sk.henrichg.phoneprofilesplus.PPApplication.<clinit>(PPApplication.java:60)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.lang.Class.newInstance(Native Method)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.AppComponentFactory.instantiateApplication(AppComponentFactory.java:62)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.support.v4.app.CoreComponentFactory.instantiateApplication(CoreComponentFactory.java:49)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.Instrumentation.newApplication(Instrumentation.java:1144)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.LoadedApk.makeApplication(LoadedApk.java:1211)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6144)
2019-03-15 19:40:37.525 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.access$1100(ActivityThread.java:208)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1769)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.os.Handler.dispatchMessage(Handler.java:106)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.os.Looper.loop(Looper.java:209)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:7021)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at java.lang.reflect.Method.invoke(Native Method)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:486)
2019-03-15 19:40:37.526 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:872)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: Caused by: android.system.ErrnoException: open failed: EACCES (Permission denied)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.Linux.open(Native Method)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.ForwardingOs.open(ForwardingOs.java:167)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.BlockGuardOs.open(BlockGuardOs.java:237)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err:     at libcore.io.IoBridge.open(IoBridge.java:482)
2019-03-15 19:40:37.527 9209-9209/sk.henrichg.phoneprofilesplus W/System.err: 	... 18 more

------------------------------------------------------------------------

Permissions vz. Root/G1

checkProfileVibrationOnTouch(context, profile, permissions);
_vibrationOnTouch

checkProfileVibrateWhenRinging(context, profile, permissions);
_vibrateWhenRinging (R)

checkProfileRingtones(context, profile, permissions);
_soundRingtoneChange
_soundNotificationChange
_soundAlarmChange

checkProfileScreenTimeout(context, profile, permissions);
_deviceScreenTimeout

checkProfileScreenBrightness(context, profile, permissions);
getDeviceBrightnessChange() (R)

checkProfileAutoRotation(context, profile, permissions);
_deviceAutoRotate

checkProfileNotificationLed(context, profile, permissions);
_notificationLed (R)

checkProfileWallpaper(context, profile, permissions);
_deviceWallpaperChange

checkProfileRadioPreferences(context, profile, permissions);
_deviceWiFiAP (R)
_deviceBluetooth
_deviceMobileData (R)
_deviceNetworkType (R)
_deviceConnectToSSID

checkProfilePhoneBroadcast(context, profile, permissions);
_volumeSpeakerPhone

checkCustomProfileIcon(context, profile, permissions);
getIsIconResourceID()

checkProfileAccessNotificationPolicy(context, profile, permissions);
_volumeRingerMode

checkProfileLockDevice(context, profile, permissions);
_lockDevice (R)

checkProfileDtmfToneWhenDialing(context, profile, permissions);
_dtmfToneWhenDialing

checkProfileSoundOnTouch(context, profile, permissions);
_soundOnTouch

----------------------------------------

Optimalizacia Editora a priprava na ViewPager:

- Mozes pre Editor pouzit pre profily jeden jediny layout. Lisia sa len indikatorom v headeri.
  Ten mozes krasne schovavat, ak su vypnute indikatory
- Potom uz nie je problem vytvorit jeden jediny fragment pre profily a jeden jediny pre udalosti.
  Netreba pri zmene fiktra vytvarat nanovo cely fragment.
  Na zmenu filtra len do prislusneho fragmentu posles nove parametre, ktore teraz davas ago argumenty pri vytvarani fragmentu.
- Ked toto budes mat, nebude sa pri kasdej zmene filtra znova nacitatavat zoznam profilov a udalosti z databazy.
  Lebo adapter ich filtruje sam, podla nastaveneho filtra v aktivite.
  Treba akurat vyriesit zmenu poradia profilov a udalosti.
  Totizto v AsyncTasku ich sortujem.
- Potom bude omnoho jednoduchsie spravit ten ViewPager pre Editor.

----------------------------------------

- Dostupnost: cize Accessibility service - bud PPP zobrazuje hned v zozname alebo treba kliknut na "Nainstalovane sluzby".
  Tam treba najst "PhoneProfilesPlusExtender" a povolit ho.
- System nastavenia polohy: treba povolit pouzivanie polohy.
- Pristup k upozrneniam: treba najst v zozname "PhoneProfilesPlus" a povolt ho.
- Optimalizacia baterie: Treba hore prepnut na "Vsetky", najst "PhoneProfilesPlus" a zakazat ho. Aby neoptimalizoval.
- Setric baterie: toto pozri na Nexuse, mne to preplo na "Rezim vykonu". Tam nic nemenim.
  Ktohovie, co sa zobrazuje pri inych mobiloch. Testni.
- Povolenie "Uprava nastaveni systemu": Zobrazi sa priamo pre PPP. Cize netreba dialog.
- Povolenie "Pristup k nastaveniu Nerusit": Treba najst "PhoneProfilesPlus" a povolit ho.
- Povolenie "Vykreslit cez dalsie apliakcie": Zobrazi sa priamo pre PPP. Cize netreba dialog.
- Povolenia pre aplikaciu: ak to je z nastaveni profilu/udalosti, netreba robit nic. Ak je to Nastavenia aplikacie,
  treba kliknut na "Opravnenia" a tam povolit prislusne opravnenia.
- Stavovy riadok - Systemove nastavenia: otvori nastavenia kanala "Aktivovany profil". Tu nech si nastavi to, co potrebuje.

Totot vypada, ze je to vsetko, ale odporucam pozriet v kode, co je vsetko volane.
Pozri kedy je to volane (Android verzia) a hladaj to v nastaveniach systemu.

Hladaj: R.string.setting_screen_not_found_alert

--------------------------------------

!!! Treba testovat, ci je elapsedTime zaporny. Ak je, daj work bez setInitialDelay().
!!! TimeChangedReceiver - by mali byt spravene cez restartEvents, co je tam uz volany.
- DonationBroadcastReceiver -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- TwilightScanner -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- EventPreferencesTime -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- EventPreferencesAlarmClock -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- EventPreferencesCalendar -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- EventPreferencesCall -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- EventPreferencesSMS -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- EventPreferencesNFC -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO
- EventPreferencesNotification -> raz denne v presny cas, pouziva aj AlarmClock
HOTOVO

Tieto maju od uzivatela parameter duration, delay:
- Event.setDelayStartAlarm -> cas od now() + delay, pouziva aj AlarmClock
HOTOVO
- Event.setDelayEndAlarm -> cas od now() + delay, pouziva aj AlarmClock
HOTOVO
- ProfileDurationAlarmBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock
HOTOVO
- RunApplicationWithDelayBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock
HOTOVO
- StartEventNotificationBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock
HOTOVO

Tento sa pouziva na spracovanie udalosti na screen off ale az po jeho loknuti:
- LockDeviceAfterScreenOffBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock,
uzivatel moze zadat interval, ale len v device Settings.
HOTOVO

Tento sa pouziva na prepinanie GPS on/off:
- GeofencesScannerSwitchGPSBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock, uzivatel nemoze
zadat interval, je natvrdo 1 alebo 30 minut, podla toho, ci sa ma pouizvat GPS. Toto je kandidat na WorkManagera.
HOTOVO

Tento sa pouziva na zavretie lock device aktivity:
- LockDeviceActivityFinishBroadcastReceiver -> cas od now() + delay, pouziva aj AlarmClock,
uzivatel nemoe zadat interval, je natvrdo 20 sekund. Toto ma sledovat, ci uzivatel vypol obrazovku
a ked nie, ma sa LockDeviceActivity zavriet. Toto je kandidat na WorkManagera.
HOTOVO

--------------------------------------

https://mail.google.com/mail/u/0/#inbox/FMfcgxwGCGzLSzHXNSXxmMFsKjrPZZMT
Pozri, cele je to v implementation 'com.google.firebase:firebase-analytics:17.2.1'
Musia to upgradnut, inac ho budem musiet vyhodit.

--------------------------------------

Extender:
- Skus spravit tak, ze zavolas Intent na download apk. V URL je cislo verzie, ale typu 5.1.2.1.
  Cize toto by som musel pouzivat v PPP.
- Ako stiahnut apk:
  https://stackoverflow.com/questions/48130430/download-a-file-in-background-without-opening-browser-with-intent
  https://stackoverflow.com/questions/525204/android-download-intent
- Testni to a zisti, co sa stane, ked kilknes na tu notifikaciu po stiahnuti.
- Hlavne pozri na nazov apk po stiahnuti. Ci tam neda cislo, napr. (1), (2) atd.
- Kliknutie na notifikaciu pos tiahnuti by mala zavolat dalsi Intent na instalaciu apk.
- Tymto by som mal vyriesenu instalaciu Extendera, ci uz noveho alebo upgrade.

- Vypada to, ze parametrov, ktore pouzivaju Extender je stale viac.
- Co tak spravit daky dialog, z ktoreho sa bude dat Extender managovat?
- Aby nemuseli byt pri kazdom profil/event parametri 3 dalsie kvoli Extenderu.
- Pridaj dakde v Editore daku indikaciu, ze je Extender vyzadovany v novej verzii.
  Nieco uz o tom mas v Important info, notifikacia o tom sa zobrazi po upgrade PPP.

- Zatial pridaj aspon upozornenie, ze je stary Extender. Mozno to uz mam, kukni.
  Sprav to ako pri pravach a podobne. Pis aj verziu, ktora je vyzadovana.

Kde je treba Extender:

Profily:
- Force stop application
- Lock device

Eventy:
- Call sensor
- SMS/MMS sensor
- Application sensor
- Orientation sensor

----------------------------------------

Pozri, ci pre Bluetooth vyzadujes pravo Write system settings. Vraj to moze vypnut ten otravny dialog pre Bluetooth. Huawei mobily.

----------------------------------------

RINGERMODE_RING : dnd = ZENMODE_ALL, ringerMode = AudioManager.RINGER_MODE_NORMAL
RINGERMODE_RING_AND_VIBRATE : dnd = ZENMODE_ALL, ringerMode = AudioManager.RINGER_MODE_NORML
RINGERMODE_VIBRATE : dnd = ZENMODE_ALL, ringerMode = AudioManager.RINGER_MODE_VIBRATE
RINGERMODE_SILENT : dnd = ZENMODE_SILENT, ringerMode = AudioManager.RINGER_MODE_SILENT ???
RINGERMODE_ZENMODE:
- ZENMODE_ALL : ringerMode = profile._ringerModeForZenMode
- ZENMODE_PRIORITY : ringerMode = profile._ringerModeForZenMode
- ZENMODE_NONE : ZENMODE_ALL, ringerMode = -1 + 1000sec + ZENMODE_NONE, ringerMode = profile._ringerModeForZenMode
- ZENMODE_ALL_AND_VIBRATE : ZENMODE_ALL + ringerMode = AudioManager.RINGER_MODE_VIBRATE
- ZENMODE_ALL_PRIORITY_VIBRATE : ZENMODE_PRIORITY + ringerMode = AudioManager.RINGER_MODE_VIBRATE
- ZENMODE_ALARMS : ZENMODE_ALL, ringerMode = -1 + 1000sec + ZENMODE_ALARMS, ringerMode = profile._ringerModeForZenMode ???


----------------------------------------

Do shared preferences zapisuje aj:

Toto je o tom, ci na start zobrazovat notifikaciu Important info. Zatial necham tak.
- ImportantInfoNotification.PREF_SHOW_INFO_NOTIFICATION_ON_START
- ImportantInfoNotification.PREF_SHOW_INFO_NOTIFICATION_ON_START_VERSION

Tu si pamatam, ci ide o prvy start. Volane ak chcem zobrazit Quick guide. Zatial nechat tak.
- LauncherActivity - ApplicationPreferences.PREF_APPLICATION_FIRST_START

Toto je volane, ked sa zmeni verzia apliakcie. Nechat v shared preferences.
- PPApplication.PREF_SAVED_VERSION_CODE

Toto je pre autoregistraciu, Nechat v shared preferences.
- MobileCellsRegistrationService.PREF_MOBILE_CELLS_AUTOREGISTRATION_DURATION
- MobileCellsRegistrationService.PREF_MOBILE_CELLS_AUTOREGISTRATION_CELLS_NAME
- MobileCellsRegistrationService.PREF_MOBILE_CELLS_AUTOREGISTRATION_ENABLED
- MobileCellsRegistrationService.PREF_MOBILE_CELLS_AUTOREGISTRATION_REMAINING_DURATION

Toto je pre donation notifikaciu generovanu na pozadi. Volane raz denne, nechat v shared preferences.
- PPApplication.PREF_DAYS_AFTER_FIRST_START
- PPApplication.PREF_DONATION_NOTIFICATION_COUNT
- PPApplication.PREF_DAYS_FOR_NEXT_DONATION_NOTIFICATION
- PPApplication.PREF_DONATION_DONATED



Toto dat ku ostatnym ApplicationPreferences, cize dat aj ako staticke premenne.
- EditorProfilesActivity - ApplicationPreferences.PREF_APPLICATION_EVENT_NEVER_ASK_FOR_ENABLE_RUN
- EditorProfilesActivity - ApplicationPreferences.PREF_APPLICATION_NEVER_ASK_FOR_GRANT_ROOT
HOTOVO

Toto dat ku ostatnym aplikacnym parametrom, cize dat aj ako staticke premenne. Podobne ako ApplicationPreferences.
- EventsPrefsActivity - ApplicationPreferences.PREF_APPLICATION_EVENT_NEVER_ASK_FOR_ENABLE_RUN
HOTOVO

Toto dat ku ostatnym aplikacnym parametrom, cize dat aj ako staticke premenne. Podobne ako ApplicationPreferences.
- ExitApplicatiinActivity - ApplicationPreferences.PREF_APPLICATION_EVENT_NEVER_ASK_FOR_ENABLE_RUN
- ExitApplicatiinActivity - ApplicationPreferences.PREF_APPLICATION_NEVER_ASK_FOR_GRANT_ROOT
HOTOVO

Toto dat ku ostatnym aplikacnym parametrom, cize dat aj ako staticke premenne. Podobne ako ApplicationPreferences.
- Permissions - ApplicationPreferences.PREF_APPLICATION_NEVER_ASK_FOR_GRANT_ROOT
HOTOVO



Toto je volane z Editora, pamata si to pohlad editora. Dat ako static premenne. Podobne ako ApplicationPreferences.
- EditorEventListFragment.SP_EDITOR_ORDER_SELECTED_ITEM
HOTOVO

Toto je volane z Editora, pamata si to pohlad editora. Dat ako static premenne. Podobne ako ApplicationPreferences.
- EditorProfilesActivity.SP_EDITOR_SELECTED_VIEW
- EditorProfilesActivity.SP_EDITOR_PROFILES_VIEW_SELECTED_ITEM
- EditorProfilesActivity.SP_EDITOR_EVENTS_VIEW_SELECTED_ITEM
HOTOVO



Toto je volane aktivaciou profilu. Dat ako static premenne. Podobne ako ApplicationPreferences.
- ActivatedProfileHelper.PREF_RINGER_VOLUME
- ActivatedProfileHelper.PREF_NOTIFICATION_VOLUME
- ActivatedProfileHelper.PREF_RINGER_MODE
- ActivatedProfileHelper.PREF_ZEN_MODE
- ActivatedProfileHelper.PREF_LOCKSCREEN_DISABLED
- ActivatedProfileHelper.PREF_ACTIVATED_PROFILE_SCREEN_TIMEOUT
HOTOVO

Toto je volane aktivaciou profilu. Dat ako static premenne. Podobne ako ApplicationPreferences.
- ActivatedProfileHelper.PREF_MERGED_RING_NOTIFICATION_VOLUMES
HOTOVO

Toto je volane aktivaciou profilu. Dat ako static premenne. Podobne ako ApplicationPreferences.
- Profile.PREF_ACTIVATED_PROFILE_FOR_DURATION
- Profile.PREF_ACTIVATED_PROFILE_END_DURATION_TIME
HOTOVO



Tu si pamatam, ci zobrazovat notifikaciu o optimalizacii baterie. Dat ako static premenne. Podobne ako ApplicationPreferences.
- IgnoreBatteryOptimizationNotification.PREF_SHOW_IGNORE_BATTERY_OPTIMIZATION_NOTIFICATION_ON_START
HOTOVO

Toto je volane casto. Casto sa zapisuje log. Dat ako static premenne. Podobne ako ApplicationPreferences.
- PPApplication.PREF_ACTIVITY_LOG_ENABLED
HOTOVO

Toto sa meni casto kvoli meneniu nazvu aktivovaneho profilu. Dat ako static premenne. Podobne ako ApplicationPreferences.
- PPApplication.PREF_NOTIFICATION_PROFILE_NAME
- PPApplication.PREF_WIDGET_PROFILE_NAME
- PPApplication.PREF_ACTIVITY_PROFILE_NAME
- PPApplication.PREF_LAST_ACTIVATED_PROFILE
HOTOVO



Toto je volane z udalosti, pamata si v ako stave je spustenie udalosti. Dat ako static premenne. Podobne ako ApplicationPreferences.
- Event.PREF_EVENTS_BLOCKED
- Event.PREF_FORCE_RUN_EVENT_RUNNING
HOTOVO

Toto je pre zapis aplikacie, ktora je na pozadi. Volane casto. Dat ako static premenne. Podobne ako ApplicationPreferences.
- PPPExtenderBroadcastReceiver.PREF_APPLICATION_IN_FOREGROUND
HOTOVO


Toto je volane z udalosti, senzor hovoru. Pamatam si tu kto, kedy volal a v ako stave je hovor. Dat ako static premenne.
Podobne ako ApplicationPreferences.
- EventsHandler - EventPreferencesCall.PREF_EVENT_CALL_EVENT_TYPE
- EventsHandler - EventPreferencesCall.PREF_EVENT_CALL_PHONE_NUMBER
- EventsHandler - EventPreferencesCall.PREF_EVENT_CALL_EVENT_TIME
HOTOVO

Toto je volane z udalosti, senzor hovoru. Pamatam si tu kto, kedy volal a v ako stave je hovor. Dat ako static premenne.
Podobne ako ApplicationPreferences.
- PhoneProfilesService - EventPreferencesCall.PREF_EVENT_CALL_EVENT_TYPE
- PhoneProfilesService - EventPreferencesCall.PREF_EVENT_CALL_PHONE_NUMBER
- PhoneProfilesService - EventPreferencesCall.PREF_EVENT_CALL_EVENT_TIME
HOTOVO

Toto je volane z udalosti, senzor prislusenstva. Pamatam si tu ake prislusenstvo je pripojene. Dat ako static premenne.
Podobne ako ApplicationPreferences.
- HeadsetConnectionBroadcastReceiver.PREF_EVENT_WIRED_HEADSET_CONNECTED
- HeadsetConnectionBroadcastReceiver.PREF_EVENT_WIRED_HEADSET_MICROPHONE
- HeadsetConnectionBroadcastReceiver.PREF_EVENT_BLUETOOTH_HEADSET_CONNECTED
- HeadsetConnectionBroadcastReceiver.PREF_EVENT_BLUETOOTH_HEADSET_MICROPHONE
HOTOVO

Toto je volane z wifi skenera. Volane casto. Dat ako static premenne. Podobne ako ApplicationPreferences.
- WifiBluetoothScanner.PREF_FORCE_ONE_WIFI_SCAN
- WifiBluetoothScanner.PREF_FORCE_ONE_BLUETOOTH_SCAN
- WifiBluetoothScanner.PREF_FORCE_ONE_LE_BLUETOOTH_SCAN
HOTOVO

Toto je volane z bluetooth skenera. Volane casto. Dat ako static premenne. Podobne ako ApplicationPreferences.
- BluetoothScanWorker.PREF_EVENT_BLUETOOTH_SCAN_REQUEST
- BluetoothScanWorker.PREF_EVENT_BLUETOOTH_LE_SCAN_REQUEST
- BluetoothScanWorker.PREF_EVENT_BLUETOOTH_WAIT_FOR_RESULTS
- BluetoothScanWorker.PREF_EVENT_BLUETOOTH_WAIT_FOR_LE_RESULTS
- BluetoothScanWorker.PREF_EVENT_BLUETOOTH_SCAN_KILLED
- BluetoothScanWorker.
HOTOVO

Toto je volane z wifi skenera. Volane casto. Dat ako static premenne. Podobne ako ApplicationPreferences.
- WifiScanWorker.PREF_EVENT_WIFI_SCAN_REQUEST
- WifiScanWorker.PREF_EVENT_WIFI_WAIT_FOR_RESULTS
- WifiScanWorker.
HOTOVO

Target helps
HOTOVO

------------------------------------------------

EditorProfilesActivity.redrawProfileListFragment()
 - co tak sem zapisat do lokalnej premennej aktivity:
   - scrollToProfile = profile;
 - EditorProfilesActivity.selectFilterItem()
   - EditorProfileListFragment.changeFragmentFilter()
     - EditorProfileListFragment.doOnViewCreated(), fromOnViewCreated=false
       - tu citat EditorProfilesActivity.scrollToProfile
         - ak != null, odscrolovat do neho, vid EditorProfileListFragment.updateListView
           musis zistit, kde ten profil je, lebo zoznam sa kompletne zmenil
           - dorob do DataWraper int getProfilePosition(Profile)
         - nastavit na null
HOTOVO
- EditorProfilesActivity.redrawEventListFragment()
 - co tak sem zapisat do lokalnej premennej aktivity:
   - scrollToEvent = event;
   - EditorEventListFragment.changeFragmentFilter()
     - EditorEventListFragment.doOnViewCreated(), fromOnViewCreated=false
       - changeEventOrder(), fromOnViewCreated=false
         - changeListOrder(), fromOnViewCreated=false
           - tu citat EditorProfilesActivity.scrollToEvent
             - ak != null, odscrolovat do neho, vid EditorEventListFragment.updateListView
               musis zistit, kde ta udalost je, lebo zoznam sa kompletne zmenil
               - dorob do DataWraper int getEventPosition(Event)
             - nastavit na null
HOTOVO

//---------------------------------------

Default profile sa aktivuje ked:
- sa ide spravit manualny restart udalosti. skontoluj, ci naozaj len pri nom, ze kedy sa robi full restart
- nesedi posledne aktivovany profil s tym, co idem aktivovat
Staci, ked plati jedno z toho

Co sa posledne aktivovalo zapisuje DataWrapper._activateProfile cez Profile.saveProfileToSharedPreferences()

Full restart sa robi, ked senzorType = SENSOR_TYPE_RESTART_EVENTS
Cize ked je volane DataWrapper._restartEvents() s unblockEventRun = true.
Cize:
- ActionForExternalApplicationAcivity s ACTION_RESTART_EVENTS
- DataWrapper.restartEventWithAlert()
  - ActivateProfileActivity.onOptionsItemSelected()
  - BackgroundActivateProfileActivity() - pre STARTUP_SOURCE_WIDGET a STARTUP_SOURCE_SHORTCUT
  - EditorProfileActivity.onOptionsItemSelected()
  - RestartEventsFromNotificationActivity - onOptionsItemSelected()
- PhoneProfilesService.doCommand s EXTRA_RESTART_EVENTS - tu je to ako parameter EXTRA_UNBLOCK_EVENTS_RUN, nie natvrdo
  - PPApplication.restartEvents() - tu je to ako parameter
    - PhoneProfilesPrefsActivity.doPreferenceChanged() - !!! TU SA NELOGUJE !!!
- RestartEventsWithDelayWorker - tu je to ako parameter EXTRA_UNBLOCK_EVENTS_RUN, nie natvrdo
  - DataWrapper.restartEventsWithDelay() - tu je to ako druhy parameter
    - Event.doActivateEndProfile() - ak je na koniec udalosti nakonfigurovane EATENDDO_RESTART_EVENTS
    - ProfileDurationAlarmBroadcastReceiver() - ak je na koniec trvania profilu nakonfigurovane AFTER_DURATION_DO_RESTART_EVENTS
- TimeChangedReceiver - ak nie je manualne aktivovany profil - tu pozri, kedy toto bolo robene, ale zda sa mi, ze to este na Google Play nie je.

Bez logu o restarte je:
- PhoneProfilesService.doCommand s EXTRA_RESTART_EVENTS - tu je to ako parameter EXTRA_UNBLOCK_EVENTS_RUN, nie natvrdo
  - PPApplication.restartEvents() - tu je to ako parameter
    - PhoneProfilesPrefsActivity.doPreferenceChanged() - !!! TU SA NELOGUJE !!!

------------------------------

Tu je volany ten HandlerThread
1. PhoneProfilesService.startListeningOrientationSensors()
2. OrientationScanner.onSensorChanged() - zisti, aky thread to pouziva
3. DatatWrapper.doHandleEvents()

PhoneProfilesService.startListeningOrientationSensors()
- PhoneProfilesService.startOrientatonScanner(...)
  Tu sa aj inicializuje OrientationScanner

OrientationScanner.onSensorChanged()
- toto je ok, vola to system, nikde inde toto volane byt nemoze a nie je

DatatWrapper.doHandleEvents()
- EventsHandler.handleEvents()

---

PhoneProfilesService.startOrientatonScanner(...)
- PhoneProfilesService.registerReceiversAndWorkers()
- PhoneProfilesService.unregisterReceiversAndWorkers()
- PhoneProfilesService.reregisterReceiversAndWorkers()
- PhoneProfilesService.doCommand()

---

EventsHandler.handleEvents()
- volane strasne vela krat zaujima ma restart udalosti a samotny orientacny senzor
- SENSOR_TYPE_DEVICE_ORIENTATION
  - z OrientationScanner.runEventsHandlerForOrientationChange() - zisti, aky thread to pouziva
  - z PPPExtenderBroadcastRecveiver.onReceive() - je to volane v HandlerThread - vroadcast treba, lebo senzor sleduje aplikacie na popredi

--------------------------------------------

-- elapsed

try {
    WorkManager workManager = WorkManager.getInstance(_context);
    //workManager.cancelUniqueWork("elapsedAlarmsEventDelayStartWork_"+((int) this._id));
    workManager.cancelAllWorkByTag("elapsedAlarmsEventDelayStartWork_"+((int) this._id));
} catch (Exception ignored) {}

"elapsedAlarmsShowProfileNotificationWork" -> ShowProfileNotificationBroadcastyReceiver.removeAlarm()
"elapsedAlarmsUpdateGUIWork" -> UpdateGUIBroadcastReceiver.removeAlarm()

"elapsedAlarmsProfileDurationWork_"+(int)profile._id -> ProfileDurationAlarmBroadcastReceicver.removeAlarm()
"elapsedAlarmsRunApplicationWithDelayWork_"+requestCode -> RunApplicationWithDelayBroadcastReceiver.removeDealyAlarm()

"elapsedAlarmsEventDelayStartWork_"+(int) event._id -> Event.removeDelayStartAlarm()
"elapsedAlarmsEventDelayEndWork_"+(int) event._id -> Event.removeDelayEndAlarm()
"elapsedAlarmsStartEventNotificationWork_"+(int)event._id -> StartEventNotificationBroadcastReceiver.

-- unique
try {
    WorkManager workManager = WorkManager.getInstance(context);
    workManager.cancelUniqueWork("disableInternalChangeWork");
    workManager.cancelAllWorkByTag("disableInternalChangeWork");
} catch (Exception ignored) {}

PhoneProfilesService.cancelWork("disableInternalChangeWork", context);
try {
    WorkManager workManager = WorkManager.getInstance(context);
    workManager.enqueueUniqueWork("disableInternalChangeWork", ExistingWorkPolicy.KEEP, disableInternalChangeWorker);
} catch (Exception ignored) {}

"disableInternalChangeWork" -> nema
"delayedWorkCloseAllApplications" -> nema
"handleEventsBluetoothLEScannerWork" -> nema
BluetoothScanWorker.WORK_TAG -> BluetoothScanWorker.canceWork()
"handleEventsBluetoothCLScannerWork" -> nema, ale asi by bolor super pridat do BluetoothScanWorker.canceWork()
"restartEventsWithDelayWork" -> nema
GeofenceScanWorker.WORK_TAG -> GeofenceScanWorker.cancelWork()
"elapsedAlarmsGeofenceScannerSwitchGPSWork" -> GeofenceScannerSwitchGPSBroadcastReceiver.removeAlarm()
LocationGeofenceEditorActivity.FETCH_ADDRESS_WORK_TAG -> nema
"elapsedAlarmsLockDeviceFinishActivity" -> LockDeviceActivityFinishBroadcastReceiver.removeAlarm()
"elapsedAlarmsLockDeviceAfterScreenOff" -> nema
"packageReplacedWork" -> nema, aj ked niekde to asi volane je
"delayedWorkAfterFirstStartWork" -> nema, aj ked niekde to asi volane je
"setBlockProfileEventsActionWork" -> nema
SearchCalendarEventsWorker.WORK_TAG -> SearchCalendarEventsWorker.cancelWork()
"handleEventsWifiScannerFromScannerWork" -> nema
"handleEventsWifiScannerFromReceiverWork" -> nema
WifiScanWorker.WORK_TAG -> WifiScanWorker.cancelWork()
"startWifiScanWork" -> nema

-----------------------------------------

BluetoothLEScanCallback21
- BluetoothScanWorker
  - startLEScan()
    WifiBluetoothScanner.bluetoothLEScanner.startScan(filters, settings, new BluetoothLEScanCallback21(context));
    - bluetooth = BluetoothAdapter.getDefaultAdapter(); //getBluetoothAdapter(context);
    - WifiBluetoothScanner.bluetoothLEScanner = bluetooth.getBluetoothLeScanner();

  - stopLEScan()
    WifiBluetoothScanner.bluetoothLEScanner.stopScan(new BluetoothLEScanCallback21(context));
    - bluetooth = BluetoothAdapter.getDefaultAdapter(); //getBluetoothAdapter(context);
    - WifiBluetoothScanner.bluetoothLEScanner = bluetooth.getBluetoothLeScanner();

startLEScan()
- BluetoothStateChangedBroadcastRecdeiver
  - onReceive()
    - HandlerThread.handler.post()
      - BluetoothScanWorker.startLEScan(appContext);
- WifiBluetoothScanner
  - doScan()
    - BluetoothScanWorker.startLEScan(context);

stopLEScan()
- WifiBluetoothScanner
  - waitForLEBluetoothScanEnd()

doScan()
- BluetoothScanWorker
  - startScanner()

startScanner()
- BluetoothPreferenceFragmentX
  - rescanAsyncTask.doInBackground()
- Bluetootk=hScanWorker
  - doWork()

-------------------------------------------------------------

- EventsHandler.handleEvents().reactivteProfile - nastavi sa na true ak ide o restart udalosti. Pre predvoleny profil sa robi tvrdy restart
  Vtedy sa profil aj aktivuje A TO VZDY A TO JE CHYBA LEBO:
                if (profileChanged || reactivateProfile)
  A toto teda sposobuje, ze sa zaloguje aktivacia a aj sa naozaj aktivuje predvoleny profil. Cize by reactivateProfile nemal pouzivat.
  Teda nech sa aktivuje naozaj len ak sa nieco zmeni v partametroch mergnuteho profilu.
  Udalosti nech sa kludne restartuju.

- Cize kukni, kedy vlastne sa robi ten tvrdy restart a zaroven sa nezaloguje.

- Makky restart sa spravi, ak:
    if ((ApplicationPreferences.prefEventsBlocked && (!unblockEventsRun))

- Restart sa nazaloguje, ak log = false
- Cize najprv zisti, kedy je unblockEventsRun = false
  - DataWrapper.startEventsOnBoot() - log vtedy nerobi a ani tvrdy restart, teda ak ApplicationPreferences.prefEventsBlocked = true
  - TimeChangeReceiver.doWork() - log vtedy nerobi a ani tvrdy restart, teda ak ApplicationPreferences.prefEventsBlocked = true


DataWrapper.startEventsOnBoot()
- DataWrapper.firstStartEvents()
-- Vola restartEventsWithRescan(false, ???, false, false) ak ma zapnute ApplicationPreferences.applicationStartEvents
   - cize unblockEventsRun = false
   - Zavola sa _restartEventsWithRescan(false, false);
     - zavola sa restartEvents(false, false);
       - zavola sa _restartEvents(false, false)
         - unblockEventsRun je sice false, ale ziadna udalost nie je blokovana
           - zavola sa EventsHandler.handleEvents() s SENSOR_RESTART_EVENTS
             cize sa robi tvrdy restart udalosti. Ten sa teda robi pre kazde volanie DataWrapper.firstStartEvents()
             ak nebezi ziadna udalost, tak 100%, cize pre predvoleny profil tiez 100%

-- Inac vypne global events run a vola activateProfileOnBoot()

TimeChangeReceiver.doWork()
- TimeChangeReceiver.onReceive()

DataWrapper.firstStartEvents()
- BootupReceiver.onReceive()

- DelayedWorksWorker.doWork() = pre DELAYED_WORK_PACKAGE_REPLACED
  - PackageReplacedReceiver.onReceive()
  - DataWrapper.doForFirstStart()

- PhoneProfilesService.doForFirstStart()
  - DatatWrapper.pauseAllEvents(false, false) - !!! Co toto robi? Sa mi zda, ze tu by mohlo zapisat aktivaciu profilu, teda ak sa tu merguju
    Vypada to tak, ze nerobi nic, kedze ziadna udalost nebezi a oba partametre su false.

---------------

Nativna notifikacia:

API level < 24 nema dekorator, tak pre ne nedovol nastavit velkost.
API level >= 24 ma dekorator, dovol nastavit zobrazovanie ikony profilu
Pouzivaj to len ak je typ native, inac to zakaz.
Cize pridaj novy parameter pre zobrazovanie ikony. Nech to je switch.

----------------

Full restart udalosti:
- prechadza vsetky udalosti jednu za druhou v opacnom poradi startu
- pauzuje len to co bezi, lebo nema co ine pauzovat
- potom prechadza vsetky udalosti jednu za druhou v poradi startu
- spusta to co spustit ma
Na TimeChangedReceiver spravi tzv. ciastocny restart, kde nezrusi manualne aktivovany profil, ktory blokuje udalosti.
To preto, aby sa nezmenil stav. Proste, ked je manualna aktivacia, tak sa udalosti neodblokuju. Teda okrem tych, co
maju _forceRun = true. Pre ne sa blokovanie ignoruje, spustia sa.
Kedy sa blokuju udalosti:
- blokuje sa, ak sa profil aktivuje manualne
Len restart udalosti vie odblokovat ich beh. Ma na to parameter. Ide ut o ten full restart.

--------------

Start udalosti:
1. Start s delay nastavi alarm pre SENSOR_TYPE_EVENT_DELAY_START a NENASTAVI event._status na ESTATUS_RUNNING, necha ho ESTATUS_PAUSE
2. Po delay znova testuje, ci sa zmeni stav udalosti a tiez ci event._isInDelayStart je uz false. Az tu vola startEvemt(), cize nastavi ESTATUS_RUNNING.
Vysledok je, ze pocas delay je stale PAUSE az po delay je RUNNING.

Koniec udalosti:
1. Koniec s delay nastavi alarm pre SENSOR_TYPE_EVENT_DELAY_END a NENASTAVI event._status na ESTATUS_PAUSE, necha ho ESTATUS_RUNNING
2. Po delay znova testuje, ci sa zmeni stav udalosti a tiez ci event._isInDelayEnd je uz false. Az tu vola pauseEvemt(), cize nastavi ESTATUS_PAUSE.
Vysledok je, ze pocas delay je stale RUNNING az po delay je PAUSE.

--------------

NextAlarmClockBroadcastReceiver
- AlarmManager.ACTION_NEXT_ALARM_CLOCK_CHANGED
- AlarmManager.AlarmClockInfo alarmClockInfo = alarmManager.getNextAlarmClock();
- long _time = alarmClockInfo.getTriggerTime(); - cas alarmu
- PendingIntent infoPendingIntent = alarmClockInfo.getShowIntent(); - intent alarmu
  ak je null, nahadzujem PhoneProfilesService.ACTION_ALARM_CLOCK_BROADCAST_RECEIVER. Preco???
- String packageName = infoPendingIntent.getCreatorPackage();
  ak je null, nahadzujem PhoneProfilesService.ACTION_ALARM_CLOCK_BROADCAST_RECEIVER. Preco???
  ak to nie je PPP, nahadzujem PhoneProfilesService.ACTION_ALARM_CLOCK_BROADCAST_RECEIVER. OK

Cize v dvoch pripadoch nahadzujem alarm. Vypada to, ze to je blbost. Asi sa snzim podporovat co najviac typov.
Moze to sposobit, ze alarm senzor bude passed aj pri nie-budikoch !!! Toto sa mi zda uplne ze zle.
Ako kua teraz z toho von?
Asi proste, ak neviem, co je to za package, tak to odignorujem. Nebude generovat ten alarm.
A pridam teda tu podporu aplikacii. Bude novy parameter pre multiselect preferences aplikacii, ale
len aplikacii A BEZ PP a PPP. Dufam, ze toto spravit ide.
Potom uz len prejdem zoznam packages, ktore mam v tom parametri.
Zoznam uz interne podporovanych tam necham.

Pridaj aj info preference, ktore zobrazi zoznam interne podporovanych aplikacii:
// com.google.android.deskclock - Google Clock
// com.sec.android.app.clockpackage - Samsung Clock
// com.sonyericsson.organizer - Sony Clock
// com.amdroidalarmclock.amdroid - AMdroid
// com.alarmclock.xtreme.free - Alarm Clock XTreme free
// com.alarmclock.xtreme - Alarm Clock XTreme
// droom.sleepIfUCan - Alarmy (Sleep if u can)
// com.funanduseful.earlybirdalarm - Early Bird Alarm Clock
// com.apalon.alarmclock.smart - Good Morning Alarm Clock
// com.kog.alarmclock - I Can't Wake Up! Alarm Clock
// com.urbandroid.sleep - Sleep as Android
// ch.bitspin.timely - Timely
// com.angrydoughnuts.android.alarmclock - Alarm Klock

--------------

Import dat z PP:

PPP testne, ci PP je nainstaloany. Ak je, tak posle broadcast do PP, ktory, ak bezi, musi zacat posielat.
PPP caka na to, ze PP zacal. Pride z PP broadcast o zaciatku.
PP musi bezat, pretoze broadcast sa zaregistruje pri starte PP. Ako ostatne broadcasty.

V PhoneProfiles sprav export PP dát cez broadcast. PP by na to mal mať foreground servis.
PP bude postupne posielať veci jednu za druhou v broadcaste, PPP musí vedieť, čo sa poslalo.
Na konci pošle, že je koniec.
PPP toto cele zacne broadcastom do PP.
PPP tieto broadcasty zachytí a nahádže do dočasných preferences a tabuľky profilov.
(docasne preferences a tabulku daj do exceptions, aby sa neautobackupovali).
Pre profily nech najprv posle, kolko ich je.
PPP potom všetko nahádže do ostrých preferences a db. PPP bude mať menu, kde sa toto spustí.
Čiže pošle do PP broadcast, nech PP začne posielať.

Problém vidím v tom, ak PP nepošle koniec. Čiže PPP by mal vedieť toto predčasne ukončiť.
PPP nech zobrazuje notifikaciu s buttonom na ukoncenie. Mozno by bolo uplne super tiez mat zvlast
foreground servis na tento import z PP.
Tiez v menu nech zobrazuje, ze je/nie je to spustene a ak to je spustene, nech to skonci bez ulozenia.
Pocasd zapisu importnutych dat do ostrych preferences a db nech uz nejde predcasne ukoncit import.
Proste notifikaciu prepisat, nech tam nie je button na ukoncenie a tiez aj polozku menu disablovat.
PP by aj tak po poslani konca importu mal svoj servis ukoncit. Uz nema co dalej posielat.

Mozno by bolo super merat cas v PPP medzi prijatymi broadcastami, zacat merat od broadcastu, co
PPP posle na zacatie importu. Ak cas bude velky (5, 10 sekund?) tak predcasne ukonci import.
Kazdy poslany broadcast na zacatie od PPP nech PP berie ako reset, cize zacne odznova.

Tu vidim problem, ak PP nebezi. Vtedy nie je ani broadcast. Cize nech PP po zachyteni, ze ma zacat
exportovat posle do PPP, ze to zachytil a zacal. A PPP bude vediet nie len, ze PP maka, ale aj
cas medzi jeho broadcastom a prijimom odpovede od PP. Ak ziadna nepride do 5, 10 sekund, PP nebezi.
A mozem o tom informovat uzivatela.


ApplicationPreferences.backup

Toto by este slo spravit cez broadcast ze chcem toto a PP by posielal polzku za polozkou.

Ipprtovat do docasnych preferences, ktore, ak to ziskam vsetko bez chyby, zasa polozku po polozke
zapisem do PPP preferences.

Treba tu pozerat, ci taka polozka existuje v PPP a ci sa nezmenili honoty, cize treba spravit mapovanie
do tych docasnych preferences.

- applicationTheme
- applicationStartOnBoot
- applicationActivate
- applicationUnlinkRingerNotificationVolumes
- applicationForceSetMergeRingNotificationVolumes
- notificationsToast
- notificationStatusBar
- notificationStatusBarPermanent
- notificationStatusBarCancel
- notificationShowInStatusBar
- notificationHideInLockscreen
- notificationLayoutType
- notificationStatusBarStyle
- notificationPrefIndicator
- notificationBackgroundColor
- notificationTextColor
- notificationUseDecoration
- notificationShowButtonExit
- applicationBackgroundProfile
- applicationAlert
- applicationActivatorPrefIndicator
- applicationActivatorHeader
- applicationLongClickActivation
- applicationClose
- applicationActivatorGridLayout
- applicationEditorPrefIndicator
- applicationEditorHeader
- applicationWidgetListPrefIndicator
- applicationWidgetListHeader
- applicationWidgetListGridLayout
- applicationWidgetListBackground
- applicationWidgetListBackgroundType
- applicationWidgetListLightnessB
- applicationWidgetListBackgroundColor
- applicationWidgetListShowBorder
- applicationWidgetListLightnessBorder
- applicationWidgetListRoundedCorners
- applicationWidgetListLightnessT
- applicationWidgetListIconColor
- applicationWidgetListIconLightness
- applicationWidgetListCustomIconLightness
- applicationWidgetOneRowPrefIndicator
- applicationWidgetOneRowBackground
- applicationWidgetOneRowBackgroundType
- applicationWidgetOneRowLightnessB
- applicationWidgetOneRowBackgroundColor
- applicationWidgetOneRowShowBorder
- applicationWidgetOneRowLightnessBorder
- applicationWidgetOneRowRoundedCorners
- applicationWidgetOneRowLightnessT
- applicationWidgetOneRowIconColor
- applicationWidgetOneRowIconLightness
- applicationWidgetOneRowCustomIconLightness
- applicationWidgetIconBackground
- applicationWidgetIconBackgroundType
- applicationWidgetIconLightnessB
- applicationWidgetIconBackgroundColor
- applicationWidgetIconShowBorder
- applicationWidgetIconLightnessBorder
- applicationWidgetIconRoundedCorners
- applicationWidgetIconHideProfileName
- applicationWidgetIconLightnessT
- applicationWidgetIconColor
- applicationWidgetIconLightness
- applicationWidgetIconCustomIconLightness
- applicationShortcutEmblem
- applicationSamsungEdgeHeader
- applicationSamsungEdgeBackground
- applicationSamsungEdgeBackgroundType
- applicationSamsungEdgeLightnessB
- applicationSamsungEdgeBackgroundColor
- applicationSamsungEdgeLightnessT
- applicationSamsungEdgeIconColor
- applicationSamsungEdgeIconLightness
- applicationSamsungEdgeCustomIconLightness

phoneProfilesManager.backup

Toto je databaza. Tu by musel PP ju otvorit a postupne profil za profilom polozku po polozke posielat
broadcastom.
Problem je ze ako. Tych parametrov profilu je mrte vela. Da sa to spravit v cykle, ze profil po profile,
jeho polozku za polozkou.

Ipprtovat do docasnej databazy, ktoru, ak to ziskam vsetko bez chyby, zasa profil po profile,
zapisem do PPP databazy.

Treba tu pozerat, ci taka polozka profilu existuje v PPP a ci sa nezmenili honoty, cize treba spravit mapovanie
do tych docasnych poloziek profilu.

Co sa tyka udalosti: pre ne sa spytaj uzivatela, ci chce udalosti zachovat. Ak odpovie nie, tak
ich vsetky vymazem.
Ak odpovie, ze zachovat, tak neviem co s profilmi. Tie by som asi mal namapovat podla nazvu na importnute.
Tie ktore nenejdem, v udalosti nastavim, ze nema nastavene. Toto rob pre start aj end profily.

-----------------

Spustenie autoregistracie po starte PPP:

PhoneStateScanner.startAutoRegistration(true) - nastartuje registraciu pri connect skenera, aj nastartuje servis
PhoneStateScanner.startAutoRegistration(false) - zisti stav registracie, aj nastartuje servis
- volane z MobileCellsRegistrationService.startAutoRegistration(false) (s false)
- volane z PhoneStateScanner.connect() (s true)
Cize autoregistracia by sa mala pri starte skenera spustit sam od seba.

PhoneStateScanner.stopAutoRegistration() - zastavi registracny servis, vymaze zoznam udalosti, zastavi samotnu registraciu
- volane na package replaced - vzdy, je jedno ci sa zmenila verzia package
- volane z PhoneStateScanner.disconnect()

Registracny servis len zastavuje samotnu registraciu na stop button alebo ak uz vyprsal cas registracie.

Cize vlastne vsetko je to o skeneri. Ten vsak zastavuje registraciu natrvalo, ak sa ukoncuje.
Ukoncovat sa moze z roznych dovodov. Cize by nemal na disconnect zastavovat samotnu registraciu.
Lebo po jeho starte sa musi znova spustit. A samozrejme nesmie mazat aj zoznam udalosti.

!!! Zasadny problem je s PhonePstateScanner.autoRegistrationEventList. Toto je len v pamati, nie je to v shared preferences.
Treba kuknut, co sa sem dava a ako to citat a zapisat do shared preferences. Aby na start registracie sa to nacitalo.
1. Je to pole event_id. To by nemal byt problem dat do shared preferences. Kukni na to.
2. Citanie dorob do MobileCellsRegistrationService.getMobileCellsAutoRegistration().
3. Zapis dorob do MobileCellsRegistrationServicesetMobileCellsAutoRegistration().

TOTO BY SI MAL VYHODIT! AUTOREGISTRACIA MUSI NASTARTOVAT, AK BOLA SPUSTENA PREDTYM
PhoneProfilesService.doFirstStart()
- MobileCellsRegistrationService.setMobileCellsAutoRegistration(appContext, _startOnBoot || _startOnPackageReplace);
Len tu chyba spustenie

!!! Este sa pozri, kedy vlastne skener mobilnych buniek nastartuje, lebo je celkom mozne,
ze nenastartuje, lebo nie su podmienky, pritom registracny servis ma vynimku, od spustenia.
Moze sa spustit hocikedy, dokonca aj ked neulozis udalost.


--------------------

Profile duration sa aplikuje:
- ak startup source nie je servis, boot, launcher start (?),
- ak je afterDurationDo = specific profile

Co sa spravi pre duration:
- ak je predtym aktivovany profil, zapise sa, aby sa vedelo, aky aktivovat na koniec duration
- nastavi sa alarm

Aky startup source sa pouzije na restart udalosti?
Podla mna service, cize vtedy sa neuplatni duration.

A teda je celkom mozne, ze restart znova aktivuje profil, ale bez duration.
Napriklad, na zmenu time zony, na autobackup.

--------------------

Android 10

1. wifiManager.getConfiguredNetworks();
- V Extenderi:
  - bude si pamatat ako globalnu staticku premenu zoznam typu List<WifiConfiguration>
  - spravit alarm, ktory v pravidelnych intervaloch, napr. kazdych 5 minut bude robit
    (mozno netreba alarm, staci ze to spravi samotny servis, ktory sa tak ci tak vola pri kazdej
     zmene gui, testni):
    - zavola wifiManager.getConfiguredNetworks();
    - porovna vysledok s tou globalnou premennou
    - ak sa nieco zmeni posle broadcast do PP a PPP so zoznamom
  - toto spravi aj na start Extendera, aby PP a PPP mali aktualizovane udaje
- V PP a PPP:
  - bude si pamatat ako globalnu staticku premenu zoznam typu List<WifiConfiguration>
  - v doFirstStart posle do Extendera broadcast so ziadostou na aktualizaciu
    - tato ziadost sa vybai tak, ze vzdy posle zoznam, cize akoby sa nieco zmenilo
  - vsade bude pouzivat tento list, cize nebude volat wifiManager.getConfiguredNetworks();
- Treba zistit, kde vsade je potrebny tento list a podla toho pytat extender ako povinny v PP a PPP.

2. Wifi scanning
- Rozdel WifiBluetoothScanner na WifiScanner a BluetoothScanner
- ...

3. wifiManager.setWifiEnabled()
- Do Extendera

4. Wifi AP
- CmdWifiAP - testni, ci ho netreba volat s Extendera
- android.net.wifi.WIFI_AP_STATE_CHANGED - testni, ci ho netreba volat s Extendera
- ...

5. Environment.getExternalStorageDirectory()
- pouzivane len pre import/export
- uz spravene, uzivatel urci cez intent kam to ulozit
- testni pre target 29

-------------

IconWidgetProvider

1. nacitava sa konfiguracia - pouzije sa mutex: PPApplication.applicationPreferencesMutex

1.1. nastavuje sa lightness pre rozne veci

2. vytvara sa DataWrapper s parametrami ci ma byt mono, hodnota mono, lightness custom ikon
3. zistuje sa aktivovany profil, generuje ikona, indikatory nie, neppuzivaju sa

4. zistuje sa, ci je aplikacia nastartovana - tu sa mutex nepouziva. Toto rob este pred bodom 3
   a 3 rob len ak ja nastartovana

5. podla parametrov widgetu sa nastavuje:
   - background color, background alfa, border lightness, text lightness
6. zistuju sa udaje o profile
   - icon resource id, identifier
   - profile name - pomocou getProfileNameWithManualIndicator() - bez event name
   - ak je profile == null, vytvara sa prazdny profil, ktoremu sa generuje bitmapa ikony

7. tu zacina cyklus po jednotlivych widgetId
8. vytvori sa RemoteViews
9. nastavuje sa pozadie, border, ci je rounded
10. nastavuje sa ikona profilu
11. nastavuje sa farba textu
12. nastavuje sa intent pre lauch aktivity (Aktivator alebo Editor)
13. zavola sa appWidgetManager.updateAppWidget()

OneRowWidgetProvider

1. nacitava sa konfiguracia - pouzije sa mutex: PPApplication.applicationPreferencesMutex

1.1. nastavuje sa lightness pre rozne veci

2. vytvara sa DataWrapper s parametrami ci ma byt mono, hodnota mono, lightness custom ikon
3. zistuje sa aktivovany profil, generuje ikona, indikatory nie, neppuzivaju sa

4. zistuje sa, ci je aplikacia nastartovana - tu sa mutex nepouziva. Toto rob este pred bodom 3
   a 3 rob len ak ja nastartovana

5. podla parametrov widgetu sa nastavuje:
   - background color, background alfa, border lioghtness, text lightness
6. zistuju sa udaje o profile
   - icon resource id, identifier
   - profile name - pomocou getProfileNameWithManualIndicator()
     - DataWrapper nema vyplneny zoznam udalosti (je to lokalny DataWrapper widgetu), takze sa cita z databazy naozaj posledne
       spustena udalost. Zisti posledne nastartovnu udalost z timeline tabulky a z tabulky eventov potom jej meno.
   - ak je profile == null, vytvara sa prazdny profil, ktoremu sa generuje bitmapa ikony

7. tu zacina cyklus po jednotlivych widgetId
8. vytvori sa RemoteViews
9. nastavuje sa pozadie, border, ci je rounded
10. nastavuje sa ikona profilu
11. nastavuje sa farba textu
11.1. nastavuju sa indikatory profilu
11.2. nastavuje sa ikona restartu udalosti
      - zistava sa bitmapa z resource - BitmapManipulator.getBitmapFromResource()
      - nastavuje sa jej monochrome farba - BitmapManipulator.monochromeBitmap()
11.3. - nastavuje sa intent ikony restartu udalosti
12. nastavuje sa intent pre lauch aktivity (Aktivator alebo Editor)
13. zavola sa appWidgetManager.updateAppWidget()

ProfileListWidgetProvider

0. tu hned zacina cyklus po jednotlivych widgetId
1. vypocita sa isLargeLayout
2. vytvori DataWrapper - ignoruje mono hodnoty, lebo sa mono ikona generuje v buildLayout
3. zavola sa buildLayout() - ??? tu sa pre kazdy widgetId ziskavaju parametre !!! OPRAV
4. zavola sa appWidgetManager.updateAppWidget()

buildLayout()
1. nacitava sa konfiguracia - pouzije sa mutex: PPApplication.applicationPreferencesMutex
1.1. nastavuje sa lightness pre rozne veci
2. podla parametrov widgetu sa nastavuje:
   - background color, background alfa, border lioghtness, text lightness, separator lightness
3. nastavuje sa intent widgetId pre ProfileListWidgetService
4. vytvara sa RemoteViews
5. nastavuje sa pozadie, border, ci je rounded
6. zistuje sa aktivovany profil, generuje ikona, indikatory (ak sa maju zobrazovat)
7. zistuje sa, ci je aplikacia nastartovana - tu sa mutex nepouziva.
8. zistuju sa udaje o profile
   - icon resource id, identifier
   - profile name - pomocou getProfileNameWithManualIndicator()
     - DataWrapper nema vyplneny zoznam udalosti (je to lokalny DataWrapper widgetu), takze sa cita z databazy naozaj posledne
       spustena udalost. Zisti posledne nastartovnu udalost z timeline tabulky a z tabulky eventov potom jej meno.
   - ak je profile == null, vytvara sa prazdny profil, ktoremu sa generuje bitmapa ikony
9. nastavuje sa ikona, indikatory, nazov profilu
10. nastavuje sa ikona restartu udalosti
      - zistava sa bitmapa z resource - BitmapManipulator.getBitmapFromResource()
      - nastavuje sa jej monochrome farba - BitmapManipulator.monochromeBitmap()
11. nastavuje sa intent pre launch aktivity Editora do headera
    - ak je sa nezobrazuje largeLayout tak sa robi intent pre LauncherActivity
12. nastavuje sa intent ikony restartu udalosti
13. nastavuje sa adapter pre grid/list intentom pre ProfileListWidgetService
14. nastavuje sa intent pre klik na item widgetu, aktivita BackgroundActivateProfileActivity

--------

Aktivacia profilu vyvola onUpdate, je jedno ci je to z 4x1 alebo 4x4 widgetu.
Co je vetedy volane?
Na ikona restartu udalosti onUpdate nevyvola.

Toto sa spravi na aktivacu z Aktivatora po kliku na 4x1 widget:

05-29 16:47:03.826 23571-23571/sk.henrichg.phoneprofilesplus E/ProfileListWidgetProvider.onReceive: action=sk.henrichg.phoneprofilesplus.ACTION_REFRESH_LISTWIDGET
05-29 16:47:14.062 23571-23571/sk.henrichg.phoneprofilesplus E/ProfileListWidgetProvider.onReceive: action=android.appwidget.action.APPWIDGET_UPDATE

To iste sa udeje aj po aktivacii z notifikacie:
05-29 16:48:39.878 23571-23571/sk.henrichg.phoneprofilesplus E/ProfileListWidgetProvider.onReceive: action=android.appwidget.action.APPWIDGET_UPDATE
Tu sa ale nevyvola sk.henrichg.phoneprofilesplus.ACTION_REFRESH_LISTWIDGET

Cize problem je s aktivaciou profilu, je jedno, ci to je na refresh alebo nie.
Samotne prekreslenie widgetu cez PPApplication.forceUpdateGUI() to nerobi. Musi to robit nieco v aktivacii profilu.
Napadlo ma volanie background aktivity, kuknem sa, co sa vola na aktivaciu.
Profil sa aktivuje aj z notifikacie, teda toast sa zobrazi.

Chyba je v tom, ze WirkManager mi vyvolava action=android.appwidget.action.APPWIDGET_UPDATE. Je to uplne
podivne, ale vypada to tak, ze toto je ten problem.
Zatial vobec netusim, ze preco. :-(

Uz vem preco:
Problem je vo WorkMangeri. Ten resheduleruje receivre a to sposobi, ze sa zavola onUpdate widgetov.
Najdolezitejsie je, ze NESMIES equeueovat worky priamo vo widgetoch! Lebo to sposobi nekonecnu slucku!
Ale ako zabranit zavolaniu onUpdate?

Skus toto (z linku 2): One other thing you could do is to schedule another WorkRequest really far out into the future.
So, you could create a OneTimeWorkRequest with an initial delay of 10 years.

Linky:
https://commonsware.com/blog/2018/11/24/workmanager-app-widgets-side-effects.html
https://issuetracker.google.com/issues/115575872#comment4

----------------------

Test baterie - kedy a odkial sa spusta EventsHandler
- wifi scanner je opraveny, spusta sa kedy ma
- dalsi adept je PhoneStateScanner.handleEvents
  - nespusat sa casto? Mozno lebo je volanypri vicaerych eventoch z listenera.
- pozeraj aj PeriodicEventHandlerWorker - mam ho povoleny na Pixeli, mal by sa kazdych 15 minut.

---------------------

- enqueue, lebo rozne data
DelayedWorksWorker.DELAYED_WORK_AFTER_FIRST_START
RestartEventsWithDelayWorker
FetchAddressWorker
ElapsedAlarmsWorker.ELAPSED_ALARMS_PROFILE_DURATION
ElapsedAlarmsWorker.ELAPSED_ALARMS_RUN_APPLICATION_WITH_DELAY_TAG_WORK
ElapsedAlarmsWorker.ELAPSED_ALARMS_START_EVENT_NOTIFICATION_TAG_WORK

Premenuj:
- ElapsedAlarmWorker na WorkerWithoutData
- DelayedWorkWorker na WorkerWithData
a poprehaduzj podla toho vsetky worky. Podla setInputData().

----------------

Veky test volani:

zhasnutie obrazovky:
2020-07-15 22:39:50.040 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-15 22:39:50.481 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] ScreenOnOffBroadcastReceiver.onReceive: xxx
2020-07-15 22:39:50.487 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=ScreenOnOffBroadcastReceiver.onReceive
2020-07-15 22:39:50.502 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] NextAlarmClockBroadcastReceiver.onReceive: xxx
2020-07-15 22:39:50.984 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-15 22:40:10.503 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] LockDeviceAfterScreenOffBroadcastReceiver.onReceive: xxx
2020-07-15 22:40:10.509 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=LockDeviceAfterScreenOffBroadcastReceiver.doWork (1)
2020-07-15 22:40:10.529 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] NextAlarmClockBroadcastReceiver.onReceive: xxx
2020-07-15 22:40:10.914 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx

zapnutie obrazovky:
2020-07-15 22:42:29.654 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-15 22:42:29.821 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] ScreenOnOffBroadcastReceiver.onReceive: xxx
2020-07-15 22:42:29.823 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=ScreenOnOffBroadcastReceiver.onReceive
2020-07-15 22:42:29.824 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] PhoneProfilesService.commandReceiver: xxx
2020-07-15 22:42:29.825 27567-27749/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPCommand: START run - from=PhoneProfilesService.doCommand
2020-07-15 22:42:30.189 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] ScreenOnOffBroadcastReceiver.onReceive: xxx
2020-07-15 22:42:30.214 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=ScreenOnOffBroadcastReceiver.onReceive
2020-07-15 22:42:30.214 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] PhoneProfilesService.commandReceiver: xxx
2020-07-15 22:42:30.215 27567-27749/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPCommand: START run - from=PhoneProfilesService.doCommand
2020-07-15 22:42:30.324 27567-27746/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPScanners: START run - from=WifiScanWorker.cancelWork
2020-07-15 22:42:30.826 27567-27746/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPScanners: START run - from=WifiScanWorker.scheduleWork
2020-07-15 22:42:30.895 27567-27896/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  WifiScanWorker.doWork: xxxx
2020-07-15 22:42:31.385 27567-27899/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  UpdateGUIWorker.doWork: xxxx
2020-07-15 22:42:31.397 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=IconWidgetProvider.onReceive
2020-07-15 22:42:31.397 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] DashClockBroadcastReceiver.onReceive: xxx
2020-07-15 22:42:31.398 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] RefreshActivitiesBroadcastReceiver.onReceive: xxx
2020-07-15 22:42:31.398 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=DashClockBroadcastReceiver.onReceive
2020-07-15 22:42:31.402 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=OneRowWidgetProvider.onReceive
2020-07-15 22:42:31.435 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=ProfileListWidgetProvider.onReceive
2020-07-15 22:42:31.435 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=SamsungEdgeProvider.onReceive
2020-07-15 22:42:31.477 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  ShowProfileNotificationWorker.doWork: xxxx
2020-07-15 22:42:32.969 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] WifiScanBroadcastReceiver.onReceive: xxx
2020-07-15 22:42:32.973 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanBroadcastReceiver.onReceive.1
2020-07-15 22:42:33.058 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanner.doScan.2
2020-07-15 22:42:34.560 27567-27746/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPScanners: START run - from=WifiScanWorker.scheduleWork
2020-07-15 22:42:38.008 27567-27895/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  MainWorker.doWork: xxxx
2020-07-15 22:42:38.008 27567-27895/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  MainWorker.doWork: tag=handleEventsWifiScannerFromReceiverWork
2020-07-15 22:42:39.167 27567-27899/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  UpdateGUIWorker.doWork: xxxx
2020-07-15 22:42:39.179 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] DashClockBroadcastReceiver.onReceive: xxx
2020-07-15 22:42:39.180 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] RefreshActivitiesBroadcastReceiver.onReceive: xxx
2020-07-15 22:42:39.181 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=DashClockBroadcastReceiver.onReceive
2020-07-15 22:42:39.182 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=IconWidgetProvider.onReceive
2020-07-15 22:42:39.189 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=OneRowWidgetProvider.onReceive
2020-07-15 22:42:39.220 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=ProfileListWidgetProvider.onReceive
2020-07-15 22:42:39.221 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=SamsungEdgeProvider.onReceive
2020-07-15 22:42:39.275 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  ShowProfileNotificationWorker.doWork: xxxx

wifi scan pri zhasnutej obrazovke, bez zmeny SSID, profil sa nezmenil:
2020-07-15 22:57:34.609 27567-27896/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  WifiScanWorker.doWork: xxxx
2020-07-15 22:57:37.678 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] WifiScanBroadcastReceiver.onReceive: xxx
2020-07-15 22:57:37.693 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanBroadcastReceiver.onReceive.1
2020-07-15 22:57:37.801 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanner.doScan.2
2020-07-15 22:57:39.309 27567-27746/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPScanners: START run - from=WifiScanWorker.scheduleWork
2020-07-15 22:57:42.737 27567-27895/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  MainWorker.doWork: xxxx
2020-07-15 22:57:42.737 27567-27895/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  MainWorker.doWork: tag=handleEventsWifiScannerFromReceiverWork

prijem wifi scan dat, ale zo systemu, nie z PPP:
2020-07-15 22:59:03.450 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] WifiScanBroadcastReceiver.onReceive: xxx
2020-07-15 22:59:03.455 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanBroadcastReceiver.onReceive.1

wifi scan pri zhasnutej obrazovke, bez zmeny SSID, profil sa nezmenil:
2020-07-15 23:12:39.384 27567-27899/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  WifiScanWorker.doWork: xxxx
2020-07-15 23:12:42.475 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] WifiScanBroadcastReceiver.onReceive: xxx
2020-07-15 23:12:42.490 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanBroadcastReceiver.onReceive.1
2020-07-15 23:12:42.571 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanner.doScan.2
2020-07-15 23:12:44.077 27567-27746/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPScanners: START run - from=WifiScanWorker.scheduleWork
2020-07-15 23:12:47.544 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  MainWorker.doWork: xxxx
2020-07-15 23:12:47.544 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  MainWorker.doWork: tag=handleEventsWifiScannerFromReceiverWork

zapnutie obrazovky:
2020-07-15 23:12:39.384 27567-27899/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  WifiScanWorker.doWork: xxxx
2020-07-15 23:12:42.475 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] WifiScanBroadcastReceiver.onReceive: xxx
2020-07-15 23:12:42.490 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanBroadcastReceiver.onReceive.1
2020-07-15 23:12:42.571 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanner.doScan.2
2020-07-15 23:12:44.077 27567-27746/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPScanners: START run - from=WifiScanWorker.scheduleWork
2020-07-15 23:12:47.544 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  MainWorker.doWork: xxxx
2020-07-15 23:12:47.544 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  MainWorker.doWork: tag=handleEventsWifiScannerFromReceiverWork
2020-07-15 23:20:47.417 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-15 23:20:47.454 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] ScreenOnOffBroadcastReceiver.onReceive: xxx
2020-07-15 23:20:47.455 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=ScreenOnOffBroadcastReceiver.onReceive
2020-07-15 23:20:47.456 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] PhoneProfilesService.commandReceiver: xxx
2020-07-15 23:20:47.458 27567-27749/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPCommand: START run - from=PhoneProfilesService.doCommand
2020-07-15 23:20:47.889 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] WifiScanBroadcastReceiver.onReceive: xxx
2020-07-15 23:20:47.980 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanBroadcastReceiver.onReceive.1
2020-07-15 23:20:48.050 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] ScreenOnOffBroadcastReceiver.onReceive: xxx
2020-07-15 23:20:48.051 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=ScreenOnOffBroadcastReceiver.onReceive
2020-07-15 23:20:48.052 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] PhoneProfilesService.commandReceiver: xxx
2020-07-15 23:20:48.053 27567-27749/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPCommand: START run - from=PhoneProfilesService.doCommand
2020-07-15 23:20:48.227 27567-27746/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPScanners: START run - from=WifiScanWorker.cancelWork
2020-07-15 23:20:48.728 27567-27746/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPScanners: START run - from=WifiScanWorker.scheduleWork
2020-07-15 23:20:48.770 27567-27896/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  WifiScanWorker.doWork: xxxx
2020-07-15 23:20:49.270 27567-27895/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  UpdateGUIWorker.doWork: xxxx
2020-07-15 23:20:49.281 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=IconWidgetProvider.onReceive
2020-07-15 23:20:49.282 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] DashClockBroadcastReceiver.onReceive: xxx
2020-07-15 23:20:49.282 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] RefreshActivitiesBroadcastReceiver.onReceive: xxx
2020-07-15 23:20:49.282 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=DashClockBroadcastReceiver.onReceive
2020-07-15 23:20:49.284 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=OneRowWidgetProvider.onReceive
2020-07-15 23:20:49.319 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=ProfileListWidgetProvider.onReceive
2020-07-15 23:20:49.320 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=SamsungEdgeProvider.onReceive
2020-07-15 23:20:49.375 27567-27899/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  ShowProfileNotificationWorker.doWork: xxxx
2020-07-15 23:20:51.684 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] WifiScanBroadcastReceiver.onReceive: xxx
2020-07-15 23:20:51.689 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanBroadcastReceiver.onReceive.1
2020-07-15 23:20:51.707 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanner.doScan.2
2020-07-15 23:20:53.211 27567-27746/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPScanners: START run - from=WifiScanWorker.scheduleWork
2020-07-15 23:20:56.713 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  MainWorker.doWork: xxxx
2020-07-15 23:20:56.713 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  MainWorker.doWork: tag=handleEventsWifiScannerFromReceiverWork
2020-07-15 23:20:57.930 27567-27895/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  UpdateGUIWorker.doWork: xxxx
2020-07-15 23:20:57.946 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=IconWidgetProvider.onReceive
2020-07-15 23:20:57.946 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] DashClockBroadcastReceiver.onReceive: xxx
2020-07-15 23:20:57.946 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] RefreshActivitiesBroadcastReceiver.onReceive: xxx
2020-07-15 23:20:57.946 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=DashClockBroadcastReceiver.onReceive
2020-07-15 23:20:57.954 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=OneRowWidgetProvider.onReceive
2020-07-15 23:20:57.984 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=ProfileListWidgetProvider.onReceive
2020-07-15 23:20:57.985 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=SamsungEdgeProvider.onReceive
2020-07-15 23:20:58.041 27567-27899/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  ShowProfileNotificationWorker.doWork: xxxx

prijem wifi scan dat, ale zo systemu, nie z PPP:
2020-07-15 23:29:05.019 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] WifiScanBroadcastReceiver.onReceive: xxx
2020-07-15 23:29:05.023 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanBroadcastReceiver.onReceive.1

NEVIM PRECO TOTO BOLO VOLANE, NIECO SA ZMENILO V SYSTEME
2020-07-15 23:31:28.666 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-15 23:31:28.671 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx

wifi scan pri zapnutej obrazovke, bez zmeny SSID, profil sa nezmenil,
tu aj prekresloval gui (pre Editor - scanner statusy - TU BY SOM MOHOL DAT LEN EDITOR PREKRESLOVAT):
2020-07-15 23:35:53.328 27567-27896/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  WifiScanWorker.doWork: xxxx
2020-07-15 23:35:56.349 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] WifiScanBroadcastReceiver.onReceive: xxx
2020-07-15 23:35:56.351 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanBroadcastReceiver.onReceive.1
2020-07-15 23:35:56.390 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanner.doScan.2
2020-07-15 23:35:57.892 27567-27746/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPScanners: START run - from=WifiScanWorker.scheduleWork
2020-07-15 23:36:01.394 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  MainWorker.doWork: xxxx
2020-07-15 23:36:01.394 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  MainWorker.doWork: tag=handleEventsWifiScannerFromReceiverWork
2020-07-15 23:36:02.537 27567-27895/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  UpdateGUIWorker.doWork: xxxx
2020-07-15 23:36:02.551 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=IconWidgetProvider.onReceive
2020-07-15 23:36:02.559 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=OneRowWidgetProvider.onReceive
2020-07-15 23:36:02.567 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] DashClockBroadcastReceiver.onReceive: xxx
2020-07-15 23:36:02.567 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=DashClockBroadcastReceiver.onReceive
2020-07-15 23:36:02.568 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] RefreshActivitiesBroadcastReceiver.onReceive: xxx
2020-07-15 23:36:02.617 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=ProfileListWidgetProvider.onReceive
2020-07-15 23:36:02.617 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=SamsungEdgeProvider.onReceive
2020-07-15 23:36:02.676 27567-27899/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  ShowProfileNotificationWorker.doWork: xxxx

wifi scan pri zapnutej obrazovke, bez zmeny SSID, profil sa nezmenil,
tu aj prekresloval gui (pre Editor - scanner statusy - TU BY SOM MOHOL DAT LEN EDITOR PREKRESLOVAT):
2020-07-15 23:50:58.006 27567-27896/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  WifiScanWorker.doWork: xxxx
2020-07-15 23:51:00.882 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] WifiScanBroadcastReceiver.onReceive: xxx
2020-07-15 23:51:00.885 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanBroadcastReceiver.onReceive.1
2020-07-15 23:51:00.952 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanner.doScan.2
2020-07-15 23:51:02.457 27567-27746/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPScanners: START run - from=WifiScanWorker.scheduleWork
2020-07-15 23:51:05.934 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  MainWorker.doWork: xxxx
2020-07-15 23:51:05.935 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  MainWorker.doWork: tag=handleEventsWifiScannerFromReceiverWork
2020-07-15 23:51:07.083 27567-27895/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  UpdateGUIWorker.doWork: xxxx
2020-07-15 23:51:07.098 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=IconWidgetProvider.onReceive
2020-07-15 23:51:07.101 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=OneRowWidgetProvider.onReceive
2020-07-15 23:51:07.117 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] DashClockBroadcastReceiver.onReceive: xxx
2020-07-15 23:51:07.118 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=DashClockBroadcastReceiver.onReceive
2020-07-15 23:51:07.118 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] RefreshActivitiesBroadcastReceiver.onReceive: xxx
2020-07-15 23:51:07.140 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=ProfileListWidgetProvider.onReceive
2020-07-15 23:51:07.141 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=SamsungEdgeProvider.onReceive
2020-07-15 23:51:07.203 27567-27899/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  ShowProfileNotificationWorker.doWork: xxxx

prijem wifi scan dat, ale zo systemu, nie z PPP:
2020-07-15 23:59:03.175 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] WifiScanBroadcastReceiver.onReceive: xxx
2020-07-15 23:59:03.183 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=WifiScanBroadcastReceiver.onReceive.1

spustenie udalosti Noc doma, aktivovanie profilu Spanok, vyptnutie skenera Wifi:
2020-07-16 00:00:05.007 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL]  EventTimeBroadcastReceiver.onReceive: xxx
2020-07-16 00:00:05.012 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=EventTimeBroadcastReceiver.doWork
2020-07-16 00:00:05.020 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL]  EventTimeBroadcastReceiver.onReceive: xxx
2020-07-16 00:00:05.026 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] NextAlarmClockBroadcastReceiver.onReceive: xxx
2020-07-16 00:00:05.214 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] NextAlarmClockBroadcastReceiver.onReceive: xxx
2020-07-16 00:00:05.237 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] NextAlarmClockBroadcastReceiver.onReceive: xxx
2020-07-16 00:00:05.334 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] PhoneProfilesService.commandReceiver: xxx
2020-07-16 00:00:05.335 27567-27749/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPCommand: START run - from=PhoneProfilesService.doCommand
2020-07-16 00:00:05.336 27567-27753/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadRadios: START run - from=ActivateProfileHelper.executeForRadios
2020-07-16 00:00:05.341 27567-27752/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadVolumes: START run - from=ActivateProfileHelper.executeForVolumes
2020-07-16 00:00:05.408 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] RingerModeChangeReceiver.onReceive: xxx
2020-07-16 00:00:05.444 27567-27746/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPScanners: START run - from=WifiScanWorker.cancelWork
2020-07-16 00:00:05.837 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=EventTimeBroadcastReceiver.doWork
2020-07-16 00:00:06.064 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 00:00:06.066 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 00:00:06.067 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 00:00:07.081 27567-27896/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  UpdateGUIWorker.doWork: xxxx
2020-07-16 00:00:07.102 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] DashClockBroadcastReceiver.onReceive: xxx
2020-07-16 00:00:07.102 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=DashClockBroadcastReceiver.onReceive
2020-07-16 00:00:07.102 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] RefreshActivitiesBroadcastReceiver.onReceive: xxx
2020-07-16 00:00:07.104 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=IconWidgetProvider.onReceive
2020-07-16 00:00:07.108 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=OneRowWidgetProvider.onReceive
2020-07-16 00:00:07.135 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=ProfileListWidgetProvider.onReceive
2020-07-16 00:00:07.136 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=SamsungEdgeProvider.onReceive
2020-07-16 00:00:07.179 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  ShowProfileNotificationWorker.doWork: xxxx
2020-07-16 00:00:10.423 27567-27895/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  DisableScreenTimeoutInternalChangeWorker.doWork: xxxx
2020-07-16 00:00:11.418 27567-27899/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  DisableInternalChangeWorker.doWork: xxxx

zhasnutie obrazovky:
PREKVAPUJE MA TU TO VOLANIE SETTINGSCONTENTOBSERVER.ONCHANGE. MAL BY SOM ZISTIT, PRECO BOLO VOLANE:
2020-07-16 00:28:09.755 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 00:28:10.130 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] ScreenOnOffBroadcastReceiver.onReceive: xxx
2020-07-16 00:28:10.135 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=ScreenOnOffBroadcastReceiver.onReceive
2020-07-16 00:28:10.157 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] NextAlarmClockBroadcastReceiver.onReceive: xxx
2020-07-16 00:28:10.500 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 00:28:30.151 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] LockDeviceAfterScreenOffBroadcastReceiver.onReceive: xxx
2020-07-16 00:28:30.157 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=LockDeviceAfterScreenOffBroadcastReceiver.doWork (1)
2020-07-16 00:28:30.165 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] NextAlarmClockBroadcastReceiver.onReceive: xxx
2020-07-16 00:28:30.540 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 00:31:28.710 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 00:31:28.718 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx

Po zapnuti obrazovky, odojeni a zasa pripojeni mobilu do PC:
2020-07-16 01:13:23.603 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:23.642 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] BatteryChargingChangedBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:23.647 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=BatteryChargingChangedBroadcastReceiver.onReceive
2020-07-16 01:13:23.986 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:24.001 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:24.002 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:24.762 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] ScreenOnOffBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:24.765 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=ScreenOnOffBroadcastReceiver.onReceive
2020-07-16 01:13:25.522 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:25.922 27567-27896/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  UpdateGUIWorker.doWork: xxxx
2020-07-16 01:13:25.940 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=IconWidgetProvider.onReceive
2020-07-16 01:13:25.940 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] DashClockBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:25.941 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=DashClockBroadcastReceiver.onReceive
2020-07-16 01:13:25.941 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] RefreshActivitiesBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:25.944 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=OneRowWidgetProvider.onReceive
2020-07-16 01:13:25.981 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=ProfileListWidgetProvider.onReceive
2020-07-16 01:13:25.982 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=SamsungEdgeProvider.onReceive
2020-07-16 01:13:26.036 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  ShowProfileNotificationWorker.doWork: xxxx
2020-07-16 01:13:29.671 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] BatteryChargingChangedBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:29.704 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=BatteryChargingChangedBroadcastReceiver.onReceive
2020-07-16 01:13:30.003 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:32.107 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:32.162 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] ScreenOnOffBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:32.164 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=ScreenOnOffBroadcastReceiver.onReceive
2020-07-16 01:13:32.181 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] NextAlarmClockBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:32.316 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] ScreenOnOffBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:32.624 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:32.629 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=ScreenOnOffBroadcastReceiver.onReceive
2020-07-16 01:13:32.631 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] PhoneProfilesService.commandReceiver: xxx
2020-07-16 01:13:32.632 27567-27749/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadPPCommand: START run - from=PhoneProfilesService.doCommand
2020-07-16 01:13:33.003 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] ScreenOnOffBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:33.018 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:33.019 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:33.021 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=ScreenOnOffBroadcastReceiver.onReceive
2020-07-16 01:13:33.910 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:33.976 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:33.982 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:33.985 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:34.165 27567-27895/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  UpdateGUIWorker.doWork: xxxx
2020-07-16 01:13:34.165 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:34.167 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=IconWidgetProvider.onReceive
2020-07-16 01:13:34.168 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=OneRowWidgetProvider.onReceive
2020-07-16 01:13:34.170 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] DashClockBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:34.170 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] RefreshActivitiesBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:34.170 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=DashClockBroadcastReceiver.onReceive
2020-07-16 01:13:34.185 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=ProfileListWidgetProvider.onReceive
2020-07-16 01:13:34.186 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=SamsungEdgeProvider.onReceive
2020-07-16 01:13:34.217 27567-27899/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  ShowProfileNotificationWorker.doWork: xxxx
2020-07-16 01:13:35.049 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:35.703 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:35.706 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:37.323 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:52.170 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] LockDeviceAfterScreenOffBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:52.174 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=LockDeviceAfterScreenOffBroadcastReceiver.doWork (1)
2020-07-16 01:13:52.178 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] NextAlarmClockBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:52.308 27567-27745/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] SettingsContentObserver.onChange: xxx
2020-07-16 01:13:53.319 27567-27896/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  UpdateGUIWorker.doWork: xxxx
2020-07-16 01:13:53.334 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=IconWidgetProvider.onReceive
2020-07-16 01:13:53.336 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] DashClockBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:53.337 27567-27567/sk.henrichg.phoneprofilesplus E/[BROADCAST CALL] RefreshActivitiesBroadcastReceiver.onReceive: xxx
2020-07-16 01:13:53.338 27567-27745/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThread: START run - from=DashClockBroadcastReceiver.onReceive
2020-07-16 01:13:53.339 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=OneRowWidgetProvider.onReceive
2020-07-16 01:13:53.364 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=ProfileListWidgetProvider.onReceive
2020-07-16 01:13:53.370 27567-27750/sk.henrichg.phoneprofilesplus E/[HANDLER CALL] PPApplication.startHandlerThreadWidget: START run - from=SamsungEdgeProvider.onReceive
2020-07-16 01:13:53.422 27567-27897/sk.henrichg.phoneprofilesplus E/[WORKER CALL]  ShowProfileNotificationWorker.doWork: xxxx

----

Battery historian:
1. sudo apt install docker.io
2. Ako pouzivat: https://developer.android.com/topic/performance/power/setup-battery-historian
3. Spustaj ale takto:
      sudo docker run -p 20000:9999 gcr.io/android-battery-historian/stable:3.0 --port 9999
4. V Chrome potom: http://localhost:20000

----------

Observer pre kontakty a ake uri pride a ake sa pouziva:

Toto uri pride v S10 zo servisu "Contacts Migrator"
2020-07-23 18:51:27.043 29373-29480/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] ContactsContentObserver.onChange: uri=content://com.android.contacts
Vzdy chodi toto uri, ci kontakt prodas, upravis zmazes. Takze nechaj to ako to mas.

2020-07-23 18:51:27.044 29373-29480/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] ContactsContentObserver.onChange: ContactsContract.Contacts.CONTENT_URI=content://com.android.contacts/contacts
2020-07-23 18:51:27.046 29373-29480/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] ContactsContentObserver.onChange: ContactsContract.CommonDataKinds.Phone.CONTENT_URI=content://com.android.contacts/data/phones
2020-07-23 18:51:27.049 29373-29480/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] ContactsContentObserver.onChange: ContactsContract.Groups.CONTENT_SUMMARY_URI=content://com.android.contacts/groups_summary
2020-07-23 18:51:27.051 29373-29480/sk.henrichg.phoneprofilesplus E/[OBSERVER CALL] ContactsContentObserver.onChange: ContactsContract.Data.CONTENT_URI=content://com.android.contacts/data

Testni, ake uri pride pri zmene kontaktu a skupiny kontaktov:


----------

Upgrade PPP + databaza, shared preferences:

Databaza:
Problem je, ze testujem verziu ppp. Je to na tom zavisle.
Na druhej strane je toho strasne vela, co sa tam deje.
- Inicializuju sa polia, Vsetky. Tu by som asi mal proste pozriet polo po poli a ak hodnota nie je nastavena, tak
  vtedy nastavit. Bez ohladu na verziu.
- V specialnych pripadoch sa udatuju polia na ine hodnoty. Testuju sa tam zavislosti a podla toho sa to nastavuje.
  Toto treba nechat tak ako je, ale vylucit tu verziu. Proste testivat zavislosti a robit to co treba.
- onUpgrade sa vola ak je zavolane getMyWritableDatabase(). Je to volane paralelne, cize pocas tohoto
  sa kludne spusta PPP. Caka to na nasledujucom volani databazy. Co sa mi moc nepaci.
  Proste to citanie databazy je pomale.
  Momentalne sa zavola na showProfileNotification() volany z PPService.onCreate(), lebo tam je
  volany work na zobrazenie aktivovaneho profilu a ten sa cita z db. OK, aspon je to vo worku,
  ale dalsie volania db podla mna budu cakat na koniec onUpgrade(). Cas ukaze, ci zacnu dake ANR kvoli tomu vznikat.

Shared preferences:
- Tu sa len updatuje to, co treba podla verzie. Updatnut, ale len ak treba, teda ak to ma inu hodnotu akoje
  pozadovana.
- Tu sa aj restartuje servis po zmene. Toto je dobre. To by sa malo.

------------------

Privacy Policy - novy web:
sites.google.com/site/phoneprofiles
- https://sites.google.com/site/phoneprofiles/home/privacy-policy
sites.google.com/site/phoneprofilesplus
- https://sites.google.com/site/phoneprofilesplus/home/privacy-policy

------------------

Toto daj do Important info. Je to ako nastavit PPP pre znizenie spotreby baterie:

1. Battery optimization, must by dislabled - it is PPP Settings/System/Ignore battery optimization
2. Scanning intervals, set it >= recommended
    - Background scanning = 15 minutes
    - Location scanning = 15 minutes
    - Wi-Fi scanning = 15 minutes
    - Bluetooth scanning = 15 minutes
    - Orientation scanning = 10 seconds
3. For location scanning disable "Use GPS when not in Power Save mode". This is required only when another location sources are not available.
    Location sources used by Android:
    - Wi-Fi
    - Bluetooth
    - network
    - mobile cells
    - GPS
4. For increasing location accuracy, you can force usage of Wi-Fi and BLuetooth as source. For this, enable it in Location system setting "Wi-Fi and Bluetooth scanning"
5. Battery sensor: do not use battery levels when are not needed. Set levels: 0%-100%

---------------------

Orientation sensor:
Light senzor sa generuje hrozne casto. Na Samsungu donekonecna a par krat za sekundu.
Spravil som sice:
- ze sa neregistruje, ak ziadna udalost ho nepouziva
- ze sa ma handler volat az o polovicu intervalu
Ale aj tak to musi zrat vela. Kazdych 5 sekund volat eventsHandler je proste vela.
Zatial mam nenapadlo, co s tym. Do nastaveni senzora daj aspon info preference o tom ze check light zerie bateriu.

---------------------

Storage permission je vyzadovane pre RingtonePreferences, pre zmenu tonov, pre ich prehravanie? Pozri.

Permisions metody, kde sa poizva Storage permission:
READ_EXTERNAL_STORAGE:
checkPlayRingtoneNotification()
checkProfileRingtones()
checkProfileWallpaper()
checkCustomProfileIcon()
checkGallery()
checkImport()
checkExport()
checkStorage()
checkRingtonePreference()
grantWallpaperPermissions()
grantCustomProfileIconPermissions()
grantExportPermissions()
grantImportPermissions()
grantRingtonePreferenceDialogPermissions()

WRITE_EXTERNAL_STORAGE:
checkImport()
checkExport()
checkStorage()
grantExportPermissions()
grantImportPermissions()

-----------------------

Co je toto? Nastavenie tonu pri aktivacii profilu? Prehratie tonu na notifikacu?
Zistujem, ktory ton je nastaveny (najdi kde), preco by som ho mal aj prehravat? Nemam to nastavene.
2020-09-07 00:05:35.217 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:05:55.189 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:26:45.609 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:26:46.097 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:26:52.669 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:28:43.189 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:29:03.187 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other

----------------------

Event.doActivateEndProfile()
- Nerobi sa nic, ak udalost nie je na konci timeline. Toto je uplna blbost.
  Lebo sa musi robit vzdy vsetko.
- Na restart udalosti mam work, volane je
  DataWrapper.restartEventsWithDelay(5 sekund)
- Ak je undo podla poradia udalosti a existuje v timeline nejaka udalost, zoberie sa start profil
  predchadzajucej udalosti v timeline.
- Ak je undo podla posledne aktivovaneho profilu, vezme sa ten co bol aktivovany pred spustenim spracovania
  udalosti. Samostatne pause a stop v takomto pripade aktivuje profil nahodeny v shared preferences,
  cize spracovanim udalosti, manualnou aktivaciou profilu.

-----------------------

1. Na Undo sprav FIFO. Proste ukladaj postupne profily, ako sa aktivuju.
2. Ked je Undo v duration: pouzi profil, ktory je vo FIFO posledne aktivovany a zmensi FIFO o 1.
3. Ked je Undo v udalosti: ak je activateReturnProfile=true, pouzi profil, ktory je vo FIFO posledne
   aktivovany a zmensi FIFO o 1.
4. Ak je FIFO prazdne, pouzi default profil (ak je zadefinovany) alebo nastav, ze nie je nic aktivovane
   (ak default profil nie je zadefinovany).
5. Restart udalosti. Tam mam tusim activateReturnProfile=false, ked pauzujem. Pozri. Ono by to aj tak
   malo byt. Pri restarte sa nesmie nic aktivovat pri pause.

-----------------------

Kvoli comu dat este jednu verziu do GP:
- Moved lastLocation variable to PPApplication.
- Delete notification and worker of PPService notification in PPService.onCreate().
- Removed change of layout to one row in list widget.
