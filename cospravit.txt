System.Settings:
notifications_use_ring_volume ---+--> ze by na odlinkovanie zvonenia a notifikacii?
unlink_volumes_together ---------+
mute_streams_affected
mode_ringer_streams_affected

System.Global:
heads_up_notifications_enabled


Ako disablovat lockscreen, 2 kroky:
1. nastavit, ze power tlacitko nema lockovat
  /data/system/locksettings.db - lockscreen.power_button_instantly_locks (0,1)
  len je otazka, ci toto existuje aj na starsich androidoch ako 5.0
2. nastavit lockscreen timeout 
  Settings.Secure - lock_screen_lock_after_timeout (milisekundy)


povolenie/zakazanie vybrovania pri dotyku: Settings.System.HAPTIC_FEEDBACK_ENABLED (0,1)


---- Power management:

1. Ak je device v "Device Idle" mode, podla dokumentacie nerobi wifi scanning.
2. Pocas "device idle" nerobit scanning, odchytavat broadcast na zmenu modu a ak sa
   "Device Idle" vypne, zavolat EventsService (akoby to bol typ udalosti).
3. Aplikacia sa moze dostat do "App Standby" modu. Treba zistit, ako sa toto da odchytit. Ak bude v tomto mode,
   scannovat s intervalom raz tak dlhym ako je prednastavene. Ak sa vypne tento mod, spravit one scan.
4. Od Lollipopa existuje "Power Save" mod. Da sa odchytit boradcast. Mal by fungovat tak ako pri
   "App standby" mode.

--------

1. scanning - ak bezi, a dam spustit one shot scanning z preferences, neukoncit hned, ale cakat na
   ukoncenie beziaceho
2. sprav udalost na start aplikacie
3. skus spravit do profilu moznot zastavit aplikaciu
4. sprav notifikaciu ako dasboard, kde budu ikony profilov, klikom na ikonu sa profil aktivuje.
   poradie bude take iste ako pro aktivatore. Ak sa nezmestia na jednu notifikaciu, spravit dalsiu.
   Notifikacia bude mat prioritu nastavitelnu, default bude Minimal. Uzivatel si bude moct zmenit, aby sa
   takat notifikacia zobrazila aj v lockscreene. ;-)

--------

---------- PIN/password

1. ako zrusim pin/heslo

deviceManager.setPasswordMinimumLength(compName, 0);
boolean result = deviceManager.resetPassword("", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);

2. ako nahodim pin/heslo

DevicePolicyManager deviceManager = (DevicePolicyManager)getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName compName = new ComponentName(MessageService.this, LockAdmin.class);  

boolean active = deviceManager.isAdminActive(compName);  

if (active) { 
  deviceManager.setPasswordQuality(compName,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
  deviceManager.setPasswordMinimumLength(compName, 5);

  boolean result = deviceManager.resetPassword("blablabla", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);
}

3. password quality:

DevicePolicyManager.PASSWORD_QUALITY_SOMETHING - pattern lock?
DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK - tvar, odtlacok prstu?
DevicePolicyManager.PASSWORD_QUALITY_NUMERIC - pin?
DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_COMPLEX - heslo?

--------------------------------

1. timezone +02, bolo 20:06 na mobile
2. nastavil som, ze sa ma spustit o 20:10
3. zmenil som timezone na +01, cas sa zmenil na 19:06
4. Editor pise, ze sa nastartuje 21:10 casu mobilu, co je zle!!!
5. 19:10 sa nenstartoval (20:10 mojho casu), co je spravne
6. cakam kedy sa naozaj udalost spusti, predpokladam ze o 20:10 casu na mobile
7. tak 20.10 casu na mobile sa nespustil. Takze asi az 21.10 casu na mobile, tak ako pise v Editore.

Cele je to zle. Ako to opravit:
1. do DabaseHandler.onUpdate() vsetky casy v profiloch a udalostiach prepocitat na lokalny cas. Cize:
    int gmtOffset = TimeZone.getDefault().getRawOffset();
    localTimaToDB = timeFromDB - gmtOffset
2. do db ukladat lokalny cas, ziaden prepocet na UTC nerobit
3. testnut zmenu timezony, ci sa prejavuje uz v nahodenych alarmoch do AlarmManagera. Podla mna sa musi,
   ved je blbost znova nahadzovat alarmy, ak sa zmeni timezna.

Po oprave:
1. timezone +02, bolo 22:22 na mobile
2. nastavil som, ze sa ma spustit o 22:25
3. zmenil som timezone na +01, cas sa zmenil na 21:25
5. Editor pise, ze sa nastartuje 22:25 casu mobilu, co je OK
6. cakam kedy sa naozaj udalost spusti, predpokladam ze o 22:25 casu na mobile

---------------------------------

Android O:
0. Treba cakat na material-dialogs a android-job, kim sa updatnu na podporu Android O. A mozno aj
   in-app platby treba kuknut.
1. Pouzivat LayoutParams.TYPE_APPLICATION_OVERLAY - uz mam, len je to zapoznamkovane.
2. Pouzivat Context.startForegroundService() - uz mam, len je to zapoznamkovane.
   Tu je problem, ze to pada, akoby nebolo volane Service.startForeground(). Hlavne, ak servis stopnem.
3. Pouzivat JobIntentService namiesto WakefulIntentService a IntentService - servisy nie je mozne startovat, ak je app. na pozadi,
   treba to preto robit cez JobIntentService. Problem je ale ten, ze na toto sa potom pouziva JobScheduler,
   cize servis sa nespusti hned, ale to riadi JobScheduler (plati len pre Android O). :-/
   Dobre, ale je, ze to spravi wake, takze v podstate ako WakefulIntentService.
4. Pouzivat NotificationChannels. Pre hlavnu notifikaciu to uz mam, len je to zapoznamkovane. Treba to spravit pre vsetky notifikacie.

----------------------------------

Battery event:
- Hrozne moc casto to broadcastuje.
- Cize dat do preferences preference info s upozrnenim, ze sledovanie urovne baterie hodne zerie. A ze ak nechce sledovat
  uroven baterie, nech nastavia lowLevel=0, highLevel=100.
- Spravit toto:
  1. HOTOVO - Zmenit default hodnotu pre lowLevel=0, highLevel=100 (v databaze a preferences).
  2. HOTOVO - Ak ma nastaveny lowLevel=0 a highLevel=100, neregistrovat broadcast receiver Intent.ACTION_BATTERY_CHANGED.
     Ale bacha na "Power save mode", vid ApplicationPreferences.applicationPowerSaveModeInternal()
     Ak = "1" alebo "2", tak sa pouziva battery level, cize Intent.ACTION_BATTERY_CHANGED je nutny.
     Kto nastavuje PPApplication.isPowerSaveMode:
     a) BatteryService
     b) PowerSaveModeService
  3. HOTOVO - Zmenit default hodnotu pre PPP Settings = "Power save mode settings" na "off", ak nie je podpora v Android
     a na "Use battery saver", ak podpora je.
  4. Pridat novy parameter "Battery low" = broadcast Intent.ACTION_BATTERY_LOW, registrovat pre BatteryBroadcastReceiver.
  5. Pridat novy parameter "Battery OK" = broadcast Intent.ACTION_BATTERY_OKAY, registrovat pre BatteryBroadcastReceiver.
  6. HOTOVO - Pridat novy action Intent.ACTION_POWER_CONNECTED, registrovat pre BatteryBroadcastReceiver.
  7. HOTOVO - Pridat novy action Intent.ACTION_POWER_DISCONNECTED, registrovat pre BatteryBroadcastReceiver.
- Vid: https://developer.android.com/training/monitoring-device-state/battery-monitoring.html

Wi-fi, Bluetooth, Location scanning:
- Zmenit default hodnotu scan intervalu na 15 minut (v preferences)
- Dat do preferences preference info s upozornenim, ze nizky interval skenovania zerie bateriu. Odporuca sa 15 minut.
- Rescan preference - dat default Screen On.
- Dat do preferences preference info ze sa odporuca mat nastaveny Rescan preference na hodnotu s Screen On.



