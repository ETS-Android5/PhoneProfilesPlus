------------------------
Ak sa spravi reboot, onDestrou PPService nastavi, ze nie je spustena aplikacia.
Takze po boote sa PPService nespusti z PPApplication. Treba cakat na BOOT_COMPLETED.
------------------------
funkční nastavení pro Huawei P30 s Androidem 10 a EMUI 10.

nastavení-aplikace- aplikace-PPP-podrobnosti o spotřebě energie-spouštění aplikací:
Spravovat automaticky - ne
Spravovat ručně 3x ano
-automatické souštění
-sekundární souštění
-Spustit na ozadí
------------------------

Ulohy, ktore su spravene [x] a ktore nie [ ]:
[x] location event (when at point X, radius Y)
[x] app event (when app X is started)
[x] Notification event lasts until notification is gone
[x] expand/shrink event and profile preferences, maybe with a checkbox instead of an arrow and all active preferences are expanded – PPP use Android standard preference screens. Than I can only use subscreens. - Yes! If I understand you right, that was my idea.
[x] profile event (only when profile X is active, can't end event)
[x] notification event
[x] Seconds in profile duration
[x] 5 minutes as settable screen timeout
[ ] Priority Notification Event
[x] Restart events at boot option
[x] Restart events shortcut for launcher
[ ] Normal media volume, headphone media volume, Bluetooth media volume
[ ] Sony's "Stamina" mode as profile preference - skor Power save change senzor
[ ] USB connection to PC as storage device, USB connection to PC as camera, connection to USB stick in accessories parameter for events
[x] Option to delete logs after x days
[ ] Resizable grid in Activator
[ ] option to hide PPP from Launcher
[x] Not started/not shown option for app event/notification event (like WiFi and Bluetooth) (aka "Not in front/Not connected")
[ ] Set min and max CPU frequency
[ ] Open a website with profile
[x] once and never again event (creatable with an additional button in starter, only start time, end time, start battery, gets deleted after end)
[ ] toggle torch
[ ] profile/event search
[ ] "change wallpapper"->live wallpappers
[ ] Persistent profile/event: sets its options every x minutes - asi periodic sensor
[ ] Android Wear support?
[ ] (AND, OR, XOR, NOT. Or at least NOT.)<-NOT is already available in most preferences. If that stays, that does the same.
[ ] a plugin system? (very small core app, ability to install additional event preferences, maybe only time event preinstalled)
[ ] PP&PPP for PC?

------------------------

UNDO:
=====

Na "Undo profile" sa pouziva FIFO, je to vlastne zoznam profilov a udalosti v poradi, v akom sa aktivovali, spustili.

1. DataWrapper.fifoAddProfile()

PhoneProfilesService.doFirstStart() - PPApplication.prefLastActivatedProfle, 0
DataWrapper._activateProfile() - profileId (ktory sa aktivuje), 0
DataWrapper.activateProfileFromEvent() - profieId, event_id
Event.startEvent() - profileId, _id - ked nejde o merge profilov a nie je to manualna aktivacia z udalosti
Event.doActivateEndProfile() - profileId, _id - ked nejde o merge profilov a nie je to manualna aktivacia z udalosti

koniec udalosti, nie je manualne aktivovany profil:
EventsHandler.handleEvents() - defaultProfile, 0 - ak ide o aktivaciu default profilu, je nakonfigurovany
EventsHandler.handleEvents() - PPApplication.prefLastActivatedProfile, 0 - ak nie je nakonfigurovany default profile

koniec udalosti, je manualne aktivovany profil:
EventsHandler.handleEvents() - semiOldActivatedProfileId, 0 - ak je aktivovany daky profil
EventsHandler.handleEvents() - defaultProfile, 0 - ak nie je aktivovany daky profil a ide o aktivaciu default profilu, je nakonfigurovany
EventsHandler.handleEvents() - PPApplication.prefLastActivatedProfile, 0 - ak nie je aktivovany daky profil a nie je nakonfigurovany default profile

2. DataWrapper.fifoSaveProfiles()

DataWrapper.activateProfile() - pre STARTUP_SOURCE_FOR_FIRST_START - vyprazdni FIFO
EditorProfileListFragment.deleteProfile() - vymaze vymazavany profil z FIFO
EditorProfileListFragment.deleteAllProfiles() - vyprazdnenie FIFO
EventHlandler.handleEvents() - vyprazdnenie FIFO pri starte udalosti pred spustanim udalosti
PhoneProfilesService.doForFirstStart() - vyprazdnenie FIFO na prvy start, potom hned nasleduje pridanie PPApplication.prefLastActivatedProfile
PPApplication._exitApp() - vyprazdnenie FIFO na ukoncenie PPP


Ako sa robi UNDO:

Event.doActivateEndProfile() - ak je EATENDDO_UNDONE_PROFILE - pre merge an non-merge profiles
- Spravi sa zonznam FIFO udalosti, ktore nie su rovne ukoncovanej udalosti.
  Profily z ukoncovanej udalosti nas uz nezaujimaju, vsetky sa z FIFO vymazu.
- Z novovzniknuteho FIFO sa vezme posledny profil a ten sa aktivuje

ProfileDurationAlarmBroadcastReceiver._doWork() - ak je AFTER_DURATION_DO_UNDO_PROFILE
- Vymaze sa posledny profil z FIFO, j jedno, ci ma priradenu udalost
- Potom za z FIFO vezme posledny profil a ten sa aktivuje

------------------------

System.Settings:
notifications_use_ring_volume ---+--> ze by na odlinkovanie zvonenia a notifikacii?
unlink_volumes_together ---------+
mute_streams_affected
mode_ringer_streams_affected

System.Global:
heads_up_notifications_enabled

Ako disablovat lockscreen, 2 kroky:
1. nastavit, ze power tlacitko nema lockovat
  /data/system/locksettings.db - lockscreen.power_button_instantly_locks (0,1)
  len je otazka, ci toto existuje aj na starsich androidoch ako 5.0
2. nastavit lockscreen timeout 
  Settings.Secure - lock_screen_lock_after_timeout (milisekundy)

--------

4. sprav notifikaciu ako dasboard, kde budu ikony profilov, klikom na ikonu sa profil aktivuje.
   poradie bude take iste ako pro aktivatore. Ak sa nezmestia na jednu notifikaciu, spravit dalsiu.
   Notifikacia bude mat prioritu nastavitelnu, default bude Minimal. Uzivatel si bude moct zmenit, aby sa
   takat notifikacia zobrazila aj v lockscreene. ;-)

--------

---------- PIN/password

1. ako zrusim pin/heslo

deviceManager.setPasswordMinimumLength(compName, 0);
boolean result = deviceManager.resetPassword("", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);

2. ako nahodim pin/heslo

DevicePolicyManager deviceManager = (DevicePolicyManager)getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName compName = new ComponentName(MessageService.this, LockAdmin.class);  

boolean active = deviceManager.isAdminActive(compName);  

if (active) { 
  deviceManager.setPasswordQuality(compName,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
  deviceManager.setPasswordMinimumLength(compName, 5);

  boolean result = deviceManager.resetPassword("blablabla", DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY);
}

3. password quality:

DevicePolicyManager.PASSWORD_QUALITY_SOMETHING - pattern lock?
DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK - tvar, odtlacok prstu?
DevicePolicyManager.PASSWORD_QUALITY_NUMERIC - pin?
DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC - heslo?
DevicePolicyManager.PASSWORD_QUALITY_COMPLEX - heslo?

--------------------------------

NFC tag senzor - NEFUNGUJE PRI CITANI TAGU NA POZADI!

Tu mas ako sa to id cita: https://gist.github.com/luixal/5768921.

- Sprav aby to len citalo UID a to pouzivaj na identifikaciu tagu.
  Takto precitas UID: https://gist.github.com/luixal/5768921
- Na nacitanie tagu v NFCTagPreference sa vytvori nova aktivita NFCTagReadEditorActivity.
  Ta bude normalna ako je teraz NFCTagWritreActivity, ktoru zahodim.
  Zobrazovat bude precitane UID tagu a aj jeho obsah.
  Aj citanie by malo zacat automaticky, ked prilozim tag ku mobilu.
- Pridanie tagu nech hned vyvola citanie UID
- Write to tag polozku menu tagu zrus a zamen za citanir UID tagu
- Premenovanie tagu teraz je nahovno, nespravi aj zapis dso tagu, ale po novom to bude OK ako to je.
- V tabulke TABLE_NFC_TAGS pribudne polozka KEY_NT_UID = "uid". Tam sa zapise precitane uid.
- Aby bola spatna kompatibilita so starymi tagmi, bude NFCTagReadActivity citat uid aj obsah tagu.
  Ak bude uid v tabulke KEY_NT_UID prazdne, pouzije sa ako teraz obsah tagu. Inac sa pouzije uid tagu.
- Pre NFCTagReadActivity zmenit v manifeste intent filter na tento:
    <intent-filter>
        <action android:name="android.nfc.action.TAG_DISCOVERED"/>
        <category android:name="android.intent.category.DEFAULT"/>
      </intent-filter>

----------------------

Direct boot:
- Asi nemozem spravit, nepodporuje to WorkManager. :-(
- toto je super na to, aby sa PPP startol aj pri uzamknutej obrazovke.
- android.intent.action.LOCKED_BOOT_COMPLETED vid:
    https://medium.com/@jordan_shifter/direct-boot-on-android-nougat-71f06c4a7c9e
- Ak nepuzijes direct boot, tak apka pada napr. v Fabric, android_job.
  To preto, lebo chcu pouzivat shared preferences a v uzamknutej obrazovke bez direct boot
  to spadne na IllegalStateException.

  Fabric, android-job uz nepouzivam, treba testnut s Firebase Crashlytics a WorkManager

- Ako spravit podporu Direct boot:
    https://developer.android.com/training/articles/direct-boot

- Len mam taky strasne blby pocit, ze neviem ako movnut shared preferences z device do credential storage.
  Vid:
    https://developer.android.com/reference/android/content/Context#moveSharedPreferencesFrom(android.content.Context,%20java.lang.String)
    https://developer.android.com/reference/android/content/Context#moveDatabaseFrom(android.content.Context,%20java.lang.String)
  Alebo, ze by pomohlo toto?
    https://stackoverflow.com/questions/51377089/android-crashlytics-fails-on-direct-boot-due-to-disk-encryption

----------------------------------------

Optimalizacia Editora a priprava na ViewPager:

- Mozes pre Editor pouzit pre profily jeden jediny layout. Lisia sa len indikatorom v headeri.
  Ten mozes krasne schovavat, ak su vypnute indikatory
- Potom uz nie je problem vytvorit jeden jediny fragment pre profily a jeden jediny pre udalosti.
  Netreba pri zmene fiktra vytvarat nanovo cely fragment.
  Na zmenu filtra len do prislusneho fragmentu posles nove parametre, ktore teraz davas ago argumenty pri vytvarani fragmentu.
- Ked toto budes mat, nebude sa pri kasdej zmene filtra znova nacitatavat zoznam profilov a udalosti z databazy.
  Lebo adapter ich filtruje sam, podla nastaveneho filtra v aktivite.
  Treba akurat vyriesit zmenu poradia profilov a udalosti.
  Totizto v AsyncTasku ich sortujem.
- Potom bude omnoho jednoduchsie spravit ten ViewPager pre Editor.

--------------------------------------

Extender:
- Skus spravit tak, ze zavolas Intent na download apk. V URL je cislo verzie, ale typu 5.1.2.1.
  Cize toto by som musel pouzivat v PPP.
- Ako stiahnut apk:
  https://stackoverflow.com/questions/48130430/download-a-file-in-background-without-opening-browser-with-intent
  https://stackoverflow.com/questions/525204/android-download-intent
- Testni to a zisti, co sa stane, ked kilknes na tu notifikaciu po stiahnuti.
- Hlavne pozri na nazov apk po stiahnuti. Ci tam neda cislo, napr. (1), (2) atd.
- Kliknutie na notifikaciu pos tiahnuti by mala zavolat dalsi Intent na instalaciu apk.
- Tymto by som mal vyriesenu instalaciu Extendera, ci uz noveho alebo upgrade.

- Vypada to, ze parametrov, ktore pouzivaju Extender je stale viac.
- Co tak spravit daky dialog, z ktoreho sa bude dat Extender managovat?
- Aby nemuseli byt pri kazdom profil/event parametri 3 dalsie kvoli Extenderu.
- Pridaj dakde v Editore daku indikaciu, ze je Extender vyzadovany v novej verzii.
  Nieco uz o tom mas v Important info, notifikacia o tom sa zobrazi po upgrade PPP.

- Zatial pridaj aspon upozornenie, ze je stary Extender. Mozno to uz mam, kukni.
  Sprav to ako pri pravach a podobne. Pis aj verziu, ktora je vyzadovana.

Kde je treba Extender:

Profily:
- Force stop application
- Lock device

Eventy:
- Call sensor
- SMS/MMS sensor
- Application sensor
- Orientation sensor

----------------------------------------

EventsHandler.handleEvents()
- volane strasne vela krat zaujima ma restart udalosti a samotny orientacny senzor
- SENSOR_TYPE_DEVICE_ORIENTATION
  - z OrientationScanner.runEventsHandlerForOrientationChange() - zisti, aky thread to pouziva
  - z PPPExtenderBroadcastRecveiver.onReceive() - je to volane v HandlerThread - vroadcast treba, lebo senzor sleduje aplikacie na popredi

--------------

Start udalosti:
1. Start s delay nastavi alarm pre SENSOR_TYPE_EVENT_DELAY_START a NENASTAVI event._status na ESTATUS_RUNNING, necha ho ESTATUS_PAUSE
2. Po delay znova testuje, ci sa zmeni stav udalosti a tiez ci event._isInDelayStart je uz false. Az tu vola startEvemt(), cize nastavi ESTATUS_RUNNING.
Vysledok je, ze pocas delay je stale PAUSE az po delay je RUNNING.

Koniec udalosti:
1. Koniec s delay nastavi alarm pre SENSOR_TYPE_EVENT_DELAY_END a NENASTAVI event._status na ESTATUS_PAUSE, necha ho ESTATUS_RUNNING
2. Po delay znova testuje, ci sa zmeni stav udalosti a tiez ci event._isInDelayEnd je uz false. Az tu vola pauseEvemt(), cize nastavi ESTATUS_PAUSE.
Vysledok je, ze pocas delay je stale RUNNING az po delay je PAUSE.

-----------------

Aktivacia profilu vyvola onUpdate, je jedno ci je to z 4x1 alebo 4x4 widgetu.

Uz vem preco:
Problem je vo WorkMangeri. Ten resheduleruje receivre a to sposobi, ze sa zavola onUpdate widgetov.
Najdolezitejsie je, ze NESMIES equeueovat worky priamo vo widgetoch! Lebo to sposobi nekonecnu slucku!
Ale ako zabranit zavolaniu onUpdate?

Skus toto (z linku 2): One other thing you could do is to schedule another WorkRequest really far out into the future.
So, you could create a OneTimeWorkRequest with an initial delay of 10 years.

Linky:
https://commonsware.com/blog/2018/11/24/workmanager-app-widgets-side-effects.html
https://issuetracker.google.com/issues/115575872#comment4

----------------------

Battery historian:
1. sudo apt install docker.io
2. Ako pouzivat: https://developer.android.com/topic/performance/power/setup-battery-historian
3. Spustaj ale takto:
      sudo docker run -p 20000:9999 gcr.io/android-battery-historian/stable:3.0 --port 9999
4. V Chrome potom: http://localhost:20000

------------------

Toto daj do Important info. Je to ako nastavit PPP pre znizenie spotreby baterie:

1. Battery optimization, must by dislabled - it is PPP Settings/System/Ignore battery optimization
2. Scanning intervals, set it >= recommended
    - Background scanning = 15 minutes
    - Location scanning = 15 minutes
    - Wi-Fi scanning = 15 minutes
    - Bluetooth scanning = 15 minutes
    - Orientation scanning = 10 seconds
3. For location scanning disable "Use GPS when not in Power Save mode". This is required only when another location sources are not available.
    Location sources used by Android:
    - Wi-Fi
    - Bluetooth
    - network
    - mobile cells
    - GPS
4. For increasing location accuracy, you can force usage of Wi-Fi and BLuetooth as source. For this, enable it in Location system setting "Wi-Fi and Bluetooth scanning"
5. Battery sensor: do not use battery levels when are not needed. Set levels: 0%-100%

---------------------

Orientation sensor:
Light senzor sa generuje hrozne casto. Na Samsungu donekonecna a par krat za sekundu.
Spravil som sice:
- ze sa neregistruje, ak ziadna udalost ho nepouziva
- ze sa ma handler volat az o polovicu intervalu
Ale aj tak to musi zrat vela. Kazdych 5 sekund volat eventsHandler je proste vela.
Zatial mam nenapadlo, co s tym. Do nastaveni senzora daj aspon info preference o tom ze check light zerie bateriu.

-----------------------

Co je toto? Nastavenie tonu pri aktivacii profilu? Prehratie tonu na notifikacu?
Zistujem, ktory ton je nastaveny (najdi kde), preco by som ho mal aj prehravat? Nemam to nastavene.
2020-09-07 00:05:35.217 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:05:55.189 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:26:45.609 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:26:46.097 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:26:52.669 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:28:43.189 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other
2020-09-07 00:29:03.187 31399-31557/sk.henrichg.phoneprofilesplus I/RingtoneManager: path and URI match to each other

------------------------

am mám funkční nastavení pro Huawei P30 s Androidem 10 a EMUI 10.

nastavení-aplikace- aplikace-PPP-podrobnosti o spotřebě energie-spouštění aplikací:
Spravovat automaticky - ne
Spravovat ručně 3x ano
-automatické souštění
-sekundární souštění
-Spustit na ozadí
třeba se to bude hodit.

--------------------------

PPApplication.STARTUP_SOURCE_SERVICE_MANUAL
- nastavi sa pri manualnej aktivacii z udalosti

Duration ignorujem:
- pri nemanualnej aktivacii z udalosti
- pri boote

Duration neignorujem, ak na koniec duration sa ma aktivovat specificky profil, je jedno odkial je aktivacia volana.

Pri manualnej aktivacii z udalosti nerobim Undo po konci duration, ostatne robim. Proste aktivuje ten isty profil.
To aby zostal manulane aktivovany profil. Ostatne "after duration" robim.

Cize duration robim pri aktivacii od hociakeho zdroja + pri manualnej aktivacii z udalosti.
Cize musi byt profil aktivovany manualne.

Nova funkcia predlzovania duration nech ignoruje:
- manualnu aktivaciu profilu z udalosti, cize PPApplication.STARTUP_SOURCE_SERVICE_MANUAL
- nemanualnu aktivaciu z udalosti, cize PPApplication.STARTUP_SOURCE_SERVICE
- boot, cize PPApplication.STARTUP_SOURCE_BOOT

----------------------------------

Broadcast, Service z notifikacie, intentu:
Pre Android 12 vraj nefunguje, len aktivita. Pozri to.

Pre notifikacie tu mam toto (action buttony):
GrantPermissionActivity:
                Intent deleteIntent = new Intent(NOTIFICATION_DELETED_ACTION);
                PendingIntent deletePendingIntent = PendingIntent.getBroadcast(context, grantType, deleteIntent, PendingIntent.FLAG_UPDATE_CURRENT);
                mBuilder.setDeleteIntent(deletePendingIntent);

MobileCellsListener:
                        Intent deleteIntent = new Intent(MobileCellsScanner.NEW_MOBILE_CELLS_NOTIFICATION_DELETED_ACTION);
                        deleteIntent.putExtra(NotUsedMobileCellsDetectedActivity.EXTRA_MOBILE_CELL_ID, _registeredCell);
                        PendingIntent deletePendingIntent = PendingIntent.getBroadcast(context, _registeredCell, deleteIntent, PendingIntent.FLAG_UPDATE_CURRENT);
                        mBuilder.setDeleteIntent(deletePendingIntent);

                        // add action button to disable not used cells detection
                        Intent disableDetectionIntent = new Intent(MobileCellsScanner.NEW_MOBILE_CELLS_NOTIFICATION_DISABLE_ACTION);
                        disableDetectionIntent.putExtra("notificationId", _registeredCell + PPApplication.NEW_MOBILE_CELLS_NOTIFICATION_ID);
                        PendingIntent pDisableDetectionIntent = PendingIntent.getBroadcast(context, 0, disableDetectionIntent, PendingIntent.FLAG_UPDATE_CURRENT);
                        NotificationCompat.Action.Builder actionBuilder = new NotificationCompat.Action.Builder(
                                R.drawable.ic_action_exit_app_white,
                                context.getString(R.string.notification_not_used_mobile_cell_disable),
                                pDisableDetectionIntent);
                        mBuilder.addAction(actionBuilder.build());

MobileCellsRegistrationService:
            Intent stopRegistrationIntent = new Intent(ACTION_MOBILE_CELLS_REGISTRATION_STOP_BUTTON);
            PendingIntent stopRegistrationPendingIntent = PendingIntent.getBroadcast(context, 0, stopRegistrationIntent, 0);
            mBuilder.addAction(R.drawable.ic_action_stop,
                    context.getString(R.string.phone_profiles_pref_applicationEventMobileCellsRegistration_stop),
                    stopRegistrationPendingIntent);

-----

Ako zobrazovat nepriesvitnost a svetlost:

1. nepriesvitnost - sprav 9 images, ktore budu reprezentovat nepriesvitnost:
   - gulaty nech je image
   - na pozadi nech je image so stvorcekmi ako som to uz 100x videl
   - nad tym nech je biely image s prislusnyou nepriesvitnostou
   - preference nech je moj custom, ktory zobrazi vybraty image nepreisvotnosti
     dialog zasa nech zobrazuje okrem percent aj prislusne images pre kazdy item

2. svetlost - sprav 9 images, ktore budu reprezentovat svetlost:
   - gulaty nech je image
   - nad tym nech je biely image s prislusnyou svetlostou, cize od ciernej po bielu
   - preference nech je moj custom, ktory zobrazi vybraty image svetlosti
     dialog zasa nech zobrazuje okrem percent aj prislusne images pre kazdy item

Skus spravit tie images vektorove.

------------

- Better handling ob Extender version for profile.
- Change: Used is Volley to read releases files from GitHub.
- Fixed bad working Screen sensor.
- Added support for live wallpapers.
- Added "debug" string for debug version of PPP into "About application".
- Fixed grant of background location.
- Added PPP, system informations to crash report.
- Added check releases in APKPure from Editor.
- Better large screens support.
- Display toolbars menu icons with texts if possible.
- Change: Use dominant color in custom profile icon for PPP notification.
- Added PPP notification type "Force native (for custom icons)".
- Added preference for grant "Display pop-up windows while running in background" in MIUI.
- Added "Vibrate notifications" as addition to "Vibrate when ringing".
- Fixed bad working check of Extender Accessibility service.
- Added "Periodic sensor" into events.
- Changed importance of ACRA notification to HIGH.
- Change: Use WiFiAPManager for Android 10.
- Added "Random image from folder" into profile "Change wallpaper".
- Better rounded corners for menus and spinner popups.
- Added "[M] Activate specific profile, then restart events" into "After duration do" for profile activation with duration.
- Added "Disable events run" into profile "Application functions".
- Added description of widgets for Android 12.
- Direct download of PhoneProfilesPlus.apk from Github.
- Direct download of PhoneProfilesPlusExtender.apk from Github.
- WiFi Hotspot for Android 11+.
- Added help about grant (G1) permission into README.md.
